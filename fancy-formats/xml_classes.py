#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Jun 13 09:03:44 2020 by generateDS.py version 2.35.24.
# Python 3.8.3 (default, May 19 2020, 06:50:17) [MSC v.1916 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'xml_classes2.py')
#
# Command line arguments:
#   IOF.xsd
#
# Command line:
#   C:\Users\marti\.conda\envs\fancy-formats\Scripts\generateDS.py -o "xml_classes2.py" IOF.xsd
#
# Current working directory (os.getcwd()):
#   Fancy-Formats
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ControlType(str, Enum):
    """The type of a control: (ordinary) control, start, finish, crossing point
    or end of marked route."""
    CONTROL='Control'
    START='Start'
    FINISH='Finish'
    CROSSING_POINT='CrossingPoint'
    END_OF_MARKED_ROUTE='EndOfMarkedRoute'


class EventClassStatus(str, Enum):
    """The status of the class."""
    NORMAL='Normal' # The default status.
    DIVIDED='Divided' # The class has been divided in two or more classes due to a large number of entries.
    JOINED='Joined' # The class has been joined with another class due to a small number of entries.
    INVALIDATED='Invalidated' # The results are considered invalid due to technical issues such as misplaced controls. Entry fees are not refunded.
    INVALIDATED_NO_FEE='InvalidatedNoFee' # The results are considered invalid due to technical issues such as misplaced controls. Entry fees are refunded.


class EventClassification(str, Enum):
    INTERNATIONAL='International'
    NATIONAL='National'
    REGIONAL='Regional'
    LOCAL='Local'
    CLUB='Club'


class EventForm(str, Enum):
    INDIVIDUAL='Individual'
    TEAM='Team'
    RELAY='Relay'


class EventStatus(str, Enum):
    PLANNED='Planned' # The event or race is on a planning stadium and has not been submitted to any sanctioning body.
    APPLIED='Applied' # The organiser has submitted the event to the relevant sanctioning body.
    PROPOSED='Proposed' # The organiser has bid on hosting the event or race as e.g. a championship.
    SANCTIONED='Sanctioned' # The event oc race meets the relevant requirements and will happen.
    CANCELED='Canceled' # The event or race has been canceled, e.g. due to weather conditions.
    RESCHEDULED='Rescheduled' # The date of the event or race has changed. A new Event or Race element should be created in addition to the already existing element.


class RaceClassStatus(str, Enum):
    """The status of a certain race in the class."""
    START_TIMES_NOT_ALLOCATED='StartTimesNotAllocated' # The start list draw has not been made for this class in this race.
    START_TIMES_ALLOCATED='StartTimesAllocated' # The start list draw has been made for this class in this race.
    NOT_USED='NotUsed' # The class is not organised in this race, e.g. for classes that are organised in only some of the races in a multi-race event.
    COMPLETED='Completed' # The result list is complete for this class in this race.
    INVALIDATED='Invalidated' # The results are considered invalid due to technical issues such as misplaced controls. Entry fees are not refunded.
    INVALIDATED_NO_FEE='InvalidatedNoFee' # The results are considered invalid due to technical issues such as misplaced controls. Entry fees are refunded.


class RaceDiscipline(str, Enum):
    SPRINT='Sprint'
    MIDDLE='Middle'
    LONG='Long'
    ULTRALONG='Ultralong'
    OTHER='Other'


class ResultStatus(str, Enum):
    """The result status of the person or team at the time of the result
    generation."""
    OK='OK' # Finished and validated.
    FINISHED='Finished' # Finished but not yet validated.
    MISSING_PUNCH='MissingPunch' # Missing punch.
    DISQUALIFIED='Disqualified' # Disqualified (for some other reason than a missing punch).
    DID_NOT_FINISH='DidNotFinish' # Did not finish (i.e. conciously cancelling the race after having started, in contrast to MissingPunch).
    ACTIVE='Active' # Currently on course.
    INACTIVE='Inactive' # Has not yet started.
    OVER_TIME='OverTime' # Overtime, i.e. did not finish within the maximum time set by the organiser.
    SPORTING_WITHDRAWAL='SportingWithdrawal' # Sporting withdrawal (e.g. helping an injured competitor).
    NOT_COMPETING='NotCompeting' # Not competing (i.e. running outside the competition).
    MOVED='Moved' # Moved to another class.
    MOVED_UP='MovedUp' # Moved to a "better" class, in case of entry restrictions.
    DID_NOT_START='DidNotStart' # Did not start (in this race).
    DID_NOT_ENTER='DidNotEnter' # Did not enter (in this race).
    CANCELLED='Cancelled' # The competitor has cancelled his/hers entry.


class resultListModeType(str, Enum):
    """Defines the kind of information to include in the result list, and how
    to sort it. For example, the result list of a beginner's class may
    include just "finished" or "did not finish" instead of the actual
    times."""
    DEFAULT='Default' # The result list should include place and time for each competitor, and be ordered by place.
    UNORDERED='Unordered' # The result list should include place and time for each competitor, but be unordered with respect to times (e.g. sorted by competitor name).
    UNORDERED_NO_TIMES='UnorderedNoTimes' # The result list should not include any places and times, and be unordered with respect to times (e.g. sorted by competitor name).


class sexType(str, Enum):
    F='F'
    M='M'


class sexType2(str, Enum):
    B='B'
    F='F'
    M='M'


class specialInstructionType(str, Enum):
    """Any special instruction applied at the control, see the column G as
    defined in International Specification for Control Descriptions."""
    NONE='None'
    TAPED_ROUTE='TapedRoute'
    FUNNEL_TAPED_ROUTE='FunnelTapedRoute'
    MANDATORY_CROSSING_POINT='MandatoryCrossingPoint'
    MANDATORY_OUT_OF_BOUNDS_AREA_PASSAGE='MandatoryOutOfBoundsAreaPassage'


class statusType(str, Enum):
    """The status of the result list."""
    COMPLETE='Complete' # The result list is complete, i.e. all competitors are included. Used for official results after the event.
    DELTA='Delta' # The result list only contains changes since last list. Used for frequent exchange of results.
    SNAPSHOT='Snapshot' # The result list is a snapshot of the current standings. Used while the event is under way.


class statusType7(str, Enum):
    """The status of the split time."""
    OK='OK' # Control belongs to the course and has been punched (either by electronical punching or pin punching). If the time is not available or invalid, omit the Time element.
    MISSING='Missing' # Control belongs to the course but has not been punched.
    ADDITIONAL='Additional' # Control does not belong to the course, but the competitor has punched it.


class typeType(str, Enum):
    """The hierarchical level or type of an organisation."""
    IOF='IOF'
    IOF_REGION='IOFRegion'
    NATIONAL_FEDERATION='NationalFederation'
    NATIONAL_REGION='NationalRegion'
    CLUB='Club'
    SCHOOL='School'
    COMPANY='Company'
    MILITARY='Military'
    OTHER='Other'


class typeType1(str, Enum):
    WEBSITE='Website'
    START_LIST='StartList'
    RESULT_LIST='ResultList'
    OTHER='Other'


class typeType3(str, Enum):
    """The type of fee."""
    NORMAL='Normal' # The fee is a normal fee (i.e. not a late entry fee).
    LATE='Late' # Te fee is a late entry fee.


class typeType4(str, Enum):
    """The type of start time allocation request."""
    NORMAL='Normal' # No special preference; use normal start time allocations.
    EARLY_START='EarlyStart' # The competitor preferences an early start time.
    LATE_START='LateStart' # The competitor preferences a late start time.
    SEPARATED_FROM='SeparatedFrom' # The competitor preferences to start well separated in time from the person or organisation that is given by the Person or Organisation element.
    GROUPED_WITH='GroupedWith' # The competitor preferences to start close in time from the person or organisation that is given by the Person or Organisation element.


class typeType5(str, Enum):
    LEG='Leg' # The time behind refers to the best time of the competitors that are taking part on the same leg as this team member, independly of the course assigned.
    COURSE='Course' # The time behind refers to the best time of the competitors that have been assigned the same course as this team member.


class typeType6(str, Enum):
    LEG='Leg' # The position refers to all competitors that are taking part on the same leg as this team member, independly of the course assigned.
    COURSE='Course' # The position refers to all competitors that have been assigned the same course as this team member.


class typeType8(str, Enum):
    PHONE_NUMBER='PhoneNumber'
    MOBILE_PHONE_NUMBER='MobilePhoneNumber'
    FAX_NUMBER='FaxNumber'
    EMAIL_ADDRESS='EmailAddress'
    WEB_ADDRESS='WebAddress'
    OTHER='Other'


class unitType(str, Enum):
    """The type of unit used."""
    PX='px' # Pixels, used when the map is represented by a digital image.
    MM='mm' # Millimeters, used when the map is represented by a printed piece of paper.


class BaseMessageElement(GeneratedsSuper):
    """The base message element that all message elements extend.
    The version of the IOF Interface Standard that the file conforms to.
    The time when the file was created.
    The name of the software that created the file."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.iofVersion = _cast(None, iofVersion)
        self.iofVersion_nsprefix_ = None
        if isinstance(createTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createTime
        self.createTime = initvalue_
        self.creator = _cast(None, creator)
        self.creator_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseMessageElement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseMessageElement.subclass:
            return BaseMessageElement.subclass(*args_, **kwargs_)
        else:
            return BaseMessageElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_iofVersion(self):
        return self.iofVersion
    def set_iofVersion(self, iofVersion):
        self.iofVersion = iofVersion
    def get_createTime(self):
        return self.createTime
    def set_createTime(self, createTime):
        self.createTime = createTime
    def get_creator(self):
        return self.creator
    def set_creator(self, creator):
        self.creator = creator
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseMessageElement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseMessageElement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseMessageElement':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseMessageElement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseMessageElement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseMessageElement'):
        if self.iofVersion is not None and 'iofVersion' not in already_processed:
            already_processed.add('iofVersion')
            outfile.write(' iofVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.iofVersion), input_name='iofVersion')), ))
        if self.createTime is not None and 'createTime' not in already_processed:
            already_processed.add('createTime')
            outfile.write(' createTime="%s"' % self.gds_format_datetime(self.createTime, input_name='createTime'))
        if self.creator is not None and 'creator' not in already_processed:
            already_processed.add('creator')
            outfile.write(' creator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.creator), input_name='creator')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BaseMessageElement', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iofVersion', node)
        if value is not None and 'iofVersion' not in already_processed:
            already_processed.add('iofVersion')
            self.iofVersion = value
        value = find_attr_value_('createTime', node)
        if value is not None and 'createTime' not in already_processed:
            already_processed.add('createTime')
            try:
                self.createTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (createTime): %s' % exp)
        value = find_attr_value_('creator', node)
        if value is not None and 'creator' not in already_processed:
            already_processed.add('creator')
            self.creator = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BaseMessageElement


class CompetitorList(BaseMessageElement):
    """A list of competitors. This is used to exchange a "brutto" list of
    possible competitors. This should not be used to exchange entries; use
    EntryList instead."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Competitor=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CompetitorList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        if Competitor is None:
            self.Competitor = []
        else:
            self.Competitor = Competitor
        self.Competitor_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompetitorList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompetitorList.subclass:
            return CompetitorList.subclass(*args_, **kwargs_)
        else:
            return CompetitorList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Competitor(self):
        return self.Competitor
    def set_Competitor(self, Competitor):
        self.Competitor = Competitor
    def add_Competitor(self, value):
        self.Competitor.append(value)
    def insert_Competitor_at(self, index, value):
        self.Competitor.insert(index, value)
    def replace_Competitor_at(self, index, value):
        self.Competitor[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Competitor or
            self.Extensions is not None or
            super(CompetitorList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CompetitorList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompetitorList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompetitorList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompetitorList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompetitorList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompetitorList'):
        super(CompetitorList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompetitorList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CompetitorList', fromsubclass_=False, pretty_print=True):
        super(CompetitorList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Competitor_ in self.Competitor:
            namespaceprefix_ = self.Competitor_nsprefix_ + ':' if (UseCapturedNS_ and self.Competitor_nsprefix_) else ''
            Competitor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Competitor', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CompetitorList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Competitor':
            obj_ = Competitor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Competitor.append(obj_)
            obj_.original_tagname_ = 'Competitor'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(CompetitorList, self).buildChildren(child_, node, nodeName_, True)
# end class CompetitorList


class OrganisationList(BaseMessageElement):
    """A list of organisations, including address and contact information."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Organisation=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OrganisationList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationList.subclass:
            return OrganisationList.subclass(*args_, **kwargs_)
        else:
            return OrganisationList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def add_Organisation(self, value):
        self.Organisation.append(value)
    def insert_Organisation_at(self, index, value):
        self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value):
        self.Organisation[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Organisation or
            self.Extensions is not None or
            super(OrganisationList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OrganisationList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganisationList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganisationList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganisationList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganisationList'):
        super(OrganisationList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganisationList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OrganisationList', fromsubclass_=False, pretty_print=True):
        super(OrganisationList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Organisation_ in self.Organisation:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            Organisation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganisationList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(OrganisationList, self).buildChildren(child_, node, nodeName_, True)
# end class OrganisationList


class EventList(BaseMessageElement):
    """A list of events. This can be used to exchange fixtures."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Event=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EventList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        if Event is None:
            self.Event = []
        else:
            self.Event = Event
        self.Event_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventList.subclass:
            return EventList.subclass(*args_, **kwargs_)
        else:
            return EventList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def add_Event(self, value):
        self.Event.append(value)
    def insert_Event_at(self, index, value):
        self.Event.insert(index, value)
    def replace_Event_at(self, index, value):
        self.Event[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Event or
            self.Extensions is not None or
            super(EventList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EventList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventList'):
        super(EventList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EventList', fromsubclass_=False, pretty_print=True):
        super(EventList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Event_ in self.Event:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            Event_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event.append(obj_)
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(EventList, self).buildChildren(child_, node, nodeName_, True)
# end class EventList


class ClassList(BaseMessageElement):
    """A list of classes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Class=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ClassList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassList.subclass:
            return ClassList.subclass(*args_, **kwargs_)
        else:
            return ClassList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def add_Class(self, value):
        self.Class.append(value)
    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)
    def replace_Class_at(self, index, value):
        self.Class[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Class or
            self.Extensions is not None or
            super(ClassList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassList'):
        super(ClassList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassList', fromsubclass_=False, pretty_print=True):
        super(ClassList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Class_ in self.Class:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            Class_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ClassList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class.append(obj_)
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(ClassList, self).buildChildren(child_, node, nodeName_, True)
# end class ClassList


class EntryList(BaseMessageElement):
    """A list of persons and/or teams which are registered for a particular
    event."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Event=None, TeamEntry=None, PersonEntry=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EntryList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.Event = Event
        self.Event_nsprefix_ = None
        if TeamEntry is None:
            self.TeamEntry = []
        else:
            self.TeamEntry = TeamEntry
        self.TeamEntry_nsprefix_ = None
        if PersonEntry is None:
            self.PersonEntry = []
        else:
            self.PersonEntry = PersonEntry
        self.PersonEntry_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryList.subclass:
            return EntryList.subclass(*args_, **kwargs_)
        else:
            return EntryList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def get_TeamEntry(self):
        return self.TeamEntry
    def set_TeamEntry(self, TeamEntry):
        self.TeamEntry = TeamEntry
    def add_TeamEntry(self, value):
        self.TeamEntry.append(value)
    def insert_TeamEntry_at(self, index, value):
        self.TeamEntry.insert(index, value)
    def replace_TeamEntry_at(self, index, value):
        self.TeamEntry[index] = value
    def get_PersonEntry(self):
        return self.PersonEntry
    def set_PersonEntry(self, PersonEntry):
        self.PersonEntry = PersonEntry
    def add_PersonEntry(self, value):
        self.PersonEntry.append(value)
    def insert_PersonEntry_at(self, index, value):
        self.PersonEntry.insert(index, value)
    def replace_PersonEntry_at(self, index, value):
        self.PersonEntry[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Event is not None or
            self.TeamEntry or
            self.PersonEntry or
            self.Extensions is not None or
            super(EntryList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EntryList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntryList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntryList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntryList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EntryList'):
        super(EntryList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntryList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EntryList', fromsubclass_=False, pretty_print=True):
        super(EntryList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event is not None:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            self.Event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        for TeamEntry_ in self.TeamEntry:
            namespaceprefix_ = self.TeamEntry_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamEntry_nsprefix_) else ''
            TeamEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamEntry', pretty_print=pretty_print)
        for PersonEntry_ in self.PersonEntry:
            namespaceprefix_ = self.PersonEntry_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonEntry_nsprefix_) else ''
            PersonEntry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonEntry', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EntryList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'TeamEntry':
            obj_ = TeamEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamEntry.append(obj_)
            obj_.original_tagname_ = 'TeamEntry'
        elif nodeName_ == 'PersonEntry':
            obj_ = PersonEntry.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonEntry.append(obj_)
            obj_.original_tagname_ = 'PersonEntry'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(EntryList, self).buildChildren(child_, node, nodeName_, True)
# end class EntryList


class CourseData(BaseMessageElement):
    """This element defines all the control and course information for an event
    or race. Used when transferring courses from course-setting software to
    event administration software."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Event=None, RaceCourseData=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CourseData, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.Event = Event
        self.Event_nsprefix_ = None
        if RaceCourseData is None:
            self.RaceCourseData = []
        else:
            self.RaceCourseData = RaceCourseData
        self.RaceCourseData_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CourseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CourseData.subclass:
            return CourseData.subclass(*args_, **kwargs_)
        else:
            return CourseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def get_RaceCourseData(self):
        return self.RaceCourseData
    def set_RaceCourseData(self, RaceCourseData):
        self.RaceCourseData = RaceCourseData
    def add_RaceCourseData(self, value):
        self.RaceCourseData.append(value)
    def insert_RaceCourseData_at(self, index, value):
        self.RaceCourseData.insert(index, value)
    def replace_RaceCourseData_at(self, index, value):
        self.RaceCourseData[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Event is not None or
            self.RaceCourseData or
            self.Extensions is not None or
            super(CourseData, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CourseData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CourseData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CourseData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CourseData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CourseData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CourseData'):
        super(CourseData, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CourseData')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CourseData', fromsubclass_=False, pretty_print=True):
        super(CourseData, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event is not None:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            self.Event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        for RaceCourseData_ in self.RaceCourseData:
            namespaceprefix_ = self.RaceCourseData_nsprefix_ + ':' if (UseCapturedNS_ and self.RaceCourseData_nsprefix_) else ''
            RaceCourseData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RaceCourseData', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CourseData, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'RaceCourseData':
            obj_ = RaceCourseData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RaceCourseData.append(obj_)
            obj_.original_tagname_ = 'RaceCourseData'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(CourseData, self).buildChildren(child_, node, nodeName_, True)
# end class CourseData


class StartList(BaseMessageElement):
    """Contains information about the start lists for the classes in an
    event."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Event=None, ClassStart=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StartList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.Event = Event
        self.Event_nsprefix_ = None
        if ClassStart is None:
            self.ClassStart = []
        else:
            self.ClassStart = ClassStart
        self.ClassStart_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StartList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StartList.subclass:
            return StartList.subclass(*args_, **kwargs_)
        else:
            return StartList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def get_ClassStart(self):
        return self.ClassStart
    def set_ClassStart(self, ClassStart):
        self.ClassStart = ClassStart
    def add_ClassStart(self, value):
        self.ClassStart.append(value)
    def insert_ClassStart_at(self, index, value):
        self.ClassStart.insert(index, value)
    def replace_ClassStart_at(self, index, value):
        self.ClassStart[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Event is not None or
            self.ClassStart or
            self.Extensions is not None or
            super(StartList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='StartList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StartList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StartList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StartList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StartList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StartList'):
        super(StartList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StartList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='StartList', fromsubclass_=False, pretty_print=True):
        super(StartList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event is not None:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            self.Event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        for ClassStart_ in self.ClassStart:
            namespaceprefix_ = self.ClassStart_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassStart_nsprefix_) else ''
            ClassStart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassStart', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StartList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'ClassStart':
            obj_ = ClassStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassStart.append(obj_)
            obj_.original_tagname_ = 'ClassStart'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(StartList, self).buildChildren(child_, node, nodeName_, True)
# end class StartList


class ResultList(BaseMessageElement):
    """Contains information about the result lists for the classes in an event.
    The status of the result list."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, status='Complete', Event=None, ClassResult=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ResultList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.status = _cast(None, status)
        self.status_nsprefix_ = None
        self.Event = Event
        self.Event_nsprefix_ = None
        if ClassResult is None:
            self.ClassResult = []
        else:
            self.ClassResult = ClassResult
        self.ClassResult_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultList.subclass:
            return ResultList.subclass(*args_, **kwargs_)
        else:
            return ResultList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def get_ClassResult(self):
        return self.ClassResult
    def set_ClassResult(self, ClassResult):
        self.ClassResult = ClassResult
    def add_ClassResult(self, value):
        self.ClassResult.append(value)
    def insert_ClassResult_at(self, index, value):
        self.ClassResult.insert(index, value)
    def replace_ClassResult_at(self, index, value):
        self.ClassResult[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def validate_statusType(self, value):
        # Validate type statusType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Complete', 'Delta', 'Snapshot']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Event is not None or
            self.ClassResult or
            self.Extensions is not None or
            super(ResultList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ResultList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResultList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResultList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResultList'):
        super(ResultList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultList')
        if self.status != "Complete" and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.status), input_name='status')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ResultList', fromsubclass_=False, pretty_print=True):
        super(ResultList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event is not None:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            self.Event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        for ClassResult_ in self.ClassResult:
            namespaceprefix_ = self.ClassResult_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassResult_nsprefix_) else ''
            ClassResult_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassResult', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_statusType(self.status)    # validate type statusType
        super(ResultList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'ClassResult':
            obj_ = ClassResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassResult.append(obj_)
            obj_.original_tagname_ = 'ClassResult'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(ResultList, self).buildChildren(child_, node, nodeName_, True)
# end class ResultList


class ServiceRequestList(BaseMessageElement):
    """A list of service requests."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Event=None, OrganisationServiceRequest=None, PersonServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ServiceRequestList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.Event = Event
        self.Event_nsprefix_ = None
        if OrganisationServiceRequest is None:
            self.OrganisationServiceRequest = []
        else:
            self.OrganisationServiceRequest = OrganisationServiceRequest
        self.OrganisationServiceRequest_nsprefix_ = None
        if PersonServiceRequest is None:
            self.PersonServiceRequest = []
        else:
            self.PersonServiceRequest = PersonServiceRequest
        self.PersonServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestList.subclass:
            return ServiceRequestList.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Event(self):
        return self.Event
    def set_Event(self, Event):
        self.Event = Event
    def get_OrganisationServiceRequest(self):
        return self.OrganisationServiceRequest
    def set_OrganisationServiceRequest(self, OrganisationServiceRequest):
        self.OrganisationServiceRequest = OrganisationServiceRequest
    def add_OrganisationServiceRequest(self, value):
        self.OrganisationServiceRequest.append(value)
    def insert_OrganisationServiceRequest_at(self, index, value):
        self.OrganisationServiceRequest.insert(index, value)
    def replace_OrganisationServiceRequest_at(self, index, value):
        self.OrganisationServiceRequest[index] = value
    def get_PersonServiceRequest(self):
        return self.PersonServiceRequest
    def set_PersonServiceRequest(self, PersonServiceRequest):
        self.PersonServiceRequest = PersonServiceRequest
    def add_PersonServiceRequest(self, value):
        self.PersonServiceRequest.append(value)
    def insert_PersonServiceRequest_at(self, index, value):
        self.PersonServiceRequest.insert(index, value)
    def replace_PersonServiceRequest_at(self, index, value):
        self.PersonServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Event is not None or
            self.OrganisationServiceRequest or
            self.PersonServiceRequest or
            self.Extensions is not None or
            super(ServiceRequestList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ServiceRequestList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceRequestList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestList'):
        super(ServiceRequestList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ServiceRequestList', fromsubclass_=False, pretty_print=True):
        super(ServiceRequestList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Event is not None:
            namespaceprefix_ = self.Event_nsprefix_ + ':' if (UseCapturedNS_ and self.Event_nsprefix_) else ''
            self.Event.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Event', pretty_print=pretty_print)
        for OrganisationServiceRequest_ in self.OrganisationServiceRequest:
            namespaceprefix_ = self.OrganisationServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganisationServiceRequest_nsprefix_) else ''
            OrganisationServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OrganisationServiceRequest', pretty_print=pretty_print)
        for PersonServiceRequest_ in self.PersonServiceRequest:
            namespaceprefix_ = self.PersonServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonServiceRequest_nsprefix_) else ''
            PersonServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceRequestList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Event = obj_
            obj_.original_tagname_ = 'Event'
        elif nodeName_ == 'OrganisationServiceRequest':
            obj_ = OrganisationServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OrganisationServiceRequest.append(obj_)
            obj_.original_tagname_ = 'OrganisationServiceRequest'
        elif nodeName_ == 'PersonServiceRequest':
            obj_ = PersonServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonServiceRequest.append(obj_)
            obj_.original_tagname_ = 'PersonServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(ServiceRequestList, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceRequestList


class ControlCardList(BaseMessageElement):
    """Defines control card ownership, e.g. for rental control card handling
    purposes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BaseMessageElement
    def __init__(self, iofVersion='3.0', createTime=None, creator=None, Owner=None, ControlCard=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ControlCardList, self).__init__(iofVersion, createTime, creator,  **kwargs_)
        self.Owner = Owner
        self.Owner_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlCardList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlCardList.subclass:
            return ControlCardList.subclass(*args_, **kwargs_)
        else:
            return ControlCardList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Owner(self):
        return self.Owner
    def set_Owner(self, Owner):
        self.Owner = Owner
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.ControlCard or
            self.Extensions is not None or
            super(ControlCardList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ControlCardList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ControlCardList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ControlCardList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlCardList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ControlCardList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ControlCardList'):
        super(ControlCardList, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlCardList')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ControlCardList', fromsubclass_=False, pretty_print=True):
        super(ControlCardList, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            namespaceprefix_ = self.Owner_nsprefix_ + ':' if (UseCapturedNS_ and self.Owner_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOwner>%s</%sOwner>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Owner), input_name='Owner')), namespaceprefix_ , eol_))
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ControlCardList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Owner':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Owner')
            value_ = self.gds_validate_string(value_, node, 'Owner')
            self.Owner = value_
            self.Owner_nsprefix_ = child_.prefix
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
        super(ControlCardList, self).buildChildren(child_, node, nodeName_, True)
# end class ControlCardList


class Id(GeneratedsSuper):
    """Identifier element, used extensively. The id should be known and common
    for both systems taking part in the data exchange.
    The issuer of the identity, e.g. World Ranking List."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Id)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Id.subclass:
            return Id.subclass(*args_, **kwargs_)
        else:
            return Id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Id', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Id')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Id':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Id')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Id', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Id'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Id', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Id


class Person(GeneratedsSuper):
    """Represents a person. This could either be a competitor (see the
    Competitor element) or contact persons in an organisation (see the
    Organisation element)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sex=None, modifyTime=None, Id=None, Name=None, BirthDate=None, Nationality=None, Address=None, Contact=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sex = _cast(None, sex)
        self.sex_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        if Id is None:
            self.Id = []
        else:
            self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if isinstance(BirthDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(BirthDate, '%Y-%m-%d').date()
        else:
            initvalue_ = BirthDate
        self.BirthDate = initvalue_
        self.BirthDate_nsprefix_ = None
        self.Nationality = Nationality
        self.Nationality_nsprefix_ = None
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Address_nsprefix_ = None
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        self.Contact_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Person)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Person.subclass:
            return Person.subclass(*args_, **kwargs_)
        else:
            return Person(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def add_Id(self, value):
        self.Id.append(value)
    def insert_Id_at(self, index, value):
        self.Id.insert(index, value)
    def replace_Id_at(self, index, value):
        self.Id[index] = value
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_BirthDate(self):
        return self.BirthDate
    def set_BirthDate(self, BirthDate):
        self.BirthDate = BirthDate
    def get_Nationality(self):
        return self.Nationality
    def set_Nationality(self, Nationality):
        self.Nationality = Nationality
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def add_Address(self, value):
        self.Address.append(value)
    def insert_Address_at(self, index, value):
        self.Address.insert(index, value)
    def replace_Address_at(self, index, value):
        self.Address[index] = value
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def add_Contact(self, value):
        self.Contact.append(value)
    def insert_Contact_at(self, index, value):
        self.Contact.insert(index, value)
    def replace_Contact_at(self, index, value):
        self.Contact[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_sex(self):
        return self.sex
    def set_sex(self, sex):
        self.sex = sex
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_sexType(self, value):
        # Validate type sexType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['F', 'M']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on sexType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Id or
            self.Name is not None or
            self.BirthDate is not None or
            self.Nationality is not None or
            self.Address or
            self.Contact or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Person', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Person')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Person':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Person')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Person', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Person'):
        if self.sex is not None and 'sex' not in already_processed:
            already_processed.add('sex')
            outfile.write(' sex=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sex), input_name='sex')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Person', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Id_ in self.Id:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            Id_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.BirthDate is not None:
            namespaceprefix_ = self.BirthDate_nsprefix_ + ':' if (UseCapturedNS_ and self.BirthDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBirthDate>%s</%sBirthDate>%s' % (namespaceprefix_ , self.gds_format_date(self.BirthDate, input_name='BirthDate'), namespaceprefix_ , eol_))
        if self.Nationality is not None:
            namespaceprefix_ = self.Nationality_nsprefix_ + ':' if (UseCapturedNS_ and self.Nationality_nsprefix_) else ''
            self.Nationality.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Nationality', pretty_print=pretty_print)
        for Address_ in self.Address:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            Address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        for Contact_ in self.Contact:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            Contact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sex', node)
        if value is not None and 'sex' not in already_processed:
            already_processed.add('sex')
            self.sex = value
            self.validate_sexType(self.sex)    # validate type sexType
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id.append(obj_)
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            obj_ = PersonName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'BirthDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.BirthDate = dval_
            self.BirthDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'Nationality':
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Nationality = obj_
            obj_.original_tagname_ = 'Nationality'
        elif nodeName_ == 'Address':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address.append(obj_)
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact.append(obj_)
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Person


class PersonName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Family=None, Given=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Family = Family
        self.Family_nsprefix_ = None
        self.Given = Given
        self.Given_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonName.subclass:
            return PersonName.subclass(*args_, **kwargs_)
        else:
            return PersonName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Family(self):
        return self.Family
    def set_Family(self, Family):
        self.Family = Family
    def get_Given(self):
        return self.Given
    def set_Given(self, Given):
        self.Given = Given
    def hasContent_(self):
        if (
            self.Family is not None or
            self.Given is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonName'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonName', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Family is not None:
            namespaceprefix_ = self.Family_nsprefix_ + ':' if (UseCapturedNS_ and self.Family_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFamily>%s</%sFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Family), input_name='Family')), namespaceprefix_ , eol_))
        if self.Given is not None:
            namespaceprefix_ = self.Given_nsprefix_ + ':' if (UseCapturedNS_ and self.Given_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGiven>%s</%sGiven>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Given), input_name='Given')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Family':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Family')
            value_ = self.gds_validate_string(value_, node, 'Family')
            self.Family = value_
            self.Family_nsprefix_ = child_.prefix
        elif nodeName_ == 'Given':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Given')
            value_ = self.gds_validate_string(value_, node, 'Given')
            self.Given = value_
            self.Given_nsprefix_ = child_.prefix
# end class PersonName


class Competitor(GeneratedsSuper):
    """Represents information about a person in a competition context, i.e.
    including organisation and control card."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Person=None, Organisation=None, ControlCard=None, Class=None, Score=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Person = Person
        self.Person_nsprefix_ = None
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Competitor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Competitor.subclass:
            return Competitor.subclass(*args_, **kwargs_)
        else:
            return Competitor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def add_Organisation(self, value):
        self.Organisation.append(value)
    def insert_Organisation_at(self, index, value):
        self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value):
        self.Organisation[index] = value
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def add_Class(self, value):
        self.Class.append(value)
    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)
    def replace_Class_at(self, index, value):
        self.Class[index] = value
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Person is not None or
            self.Organisation or
            self.ControlCard or
            self.Class or
            self.Score or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Competitor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Competitor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Competitor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Competitor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Competitor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Competitor'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Competitor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        for Organisation_ in self.Organisation:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            Organisation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for Class_ in self.Class:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            Class_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class.append(obj_)
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Competitor


class ControlCard(GeneratedsSuper):
    """The unique identifier of the control card, i.e. card number.
    The manufacturer of the punching system, e.g. 'SI' or 'Emit'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, punchingSystem=None, modifyTime=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.punchingSystem = _cast(None, punchingSystem)
        self.punchingSystem_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlCard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlCard.subclass:
            return ControlCard.subclass(*args_, **kwargs_)
        else:
            return ControlCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_punchingSystem(self):
        return self.punchingSystem
    def set_punchingSystem(self, punchingSystem):
        self.punchingSystem = punchingSystem
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ControlCard', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ControlCard')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ControlCard':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlCard')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ControlCard', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ControlCard'):
        if self.punchingSystem is not None and 'punchingSystem' not in already_processed:
            already_processed.add('punchingSystem')
            outfile.write(' punchingSystem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.punchingSystem), input_name='punchingSystem')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ControlCard', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('punchingSystem', node)
        if value is not None and 'punchingSystem' not in already_processed:
            already_processed.add('punchingSystem')
            self.punchingSystem = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ControlCard


class Score(GeneratedsSuper):
    """The score earned in an event for some purpose, e.g. a ranking list. The
    'type' attribute is used to specify which purpose."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Score)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Score.subclass:
            return Score.subclass(*args_, **kwargs_)
        else:
            return Score(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Score', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Score')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Score':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Score')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Score', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Score'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Score', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Score


class Organisation(GeneratedsSuper):
    """Information about an organisation, i.e. address, contact person(s) etc.
    An organisation is a general term including federations, clubs, etc.
    The hierarchical level or type of an organisation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, modifyTime=None, Id=None, Name=None, ShortName=None, MediaName=None, ParentOrganisationId=None, Country=None, Address=None, Contact=None, Position=None, Account=None, Role=None, Logotype=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.ShortName = ShortName
        self.ShortName_nsprefix_ = None
        self.MediaName = MediaName
        self.MediaName_nsprefix_ = None
        self.ParentOrganisationId = ParentOrganisationId
        self.ParentOrganisationId_nsprefix_ = None
        self.Country = Country
        self.Country_nsprefix_ = None
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Address_nsprefix_ = None
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        self.Contact_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        if Account is None:
            self.Account = []
        else:
            self.Account = Account
        self.Account_nsprefix_ = None
        if Role is None:
            self.Role = []
        else:
            self.Role = Role
        self.Role_nsprefix_ = None
        if Logotype is None:
            self.Logotype = []
        else:
            self.Logotype = Logotype
        self.Logotype_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Organisation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Organisation.subclass:
            return Organisation.subclass(*args_, **kwargs_)
        else:
            return Organisation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_ShortName(self):
        return self.ShortName
    def set_ShortName(self, ShortName):
        self.ShortName = ShortName
    def get_MediaName(self):
        return self.MediaName
    def set_MediaName(self, MediaName):
        self.MediaName = MediaName
    def get_ParentOrganisationId(self):
        return self.ParentOrganisationId
    def set_ParentOrganisationId(self, ParentOrganisationId):
        self.ParentOrganisationId = ParentOrganisationId
    def get_Country(self):
        return self.Country
    def set_Country(self, Country):
        self.Country = Country
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def add_Address(self, value):
        self.Address.append(value)
    def insert_Address_at(self, index, value):
        self.Address.insert(index, value)
    def replace_Address_at(self, index, value):
        self.Address[index] = value
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def add_Contact(self, value):
        self.Contact.append(value)
    def insert_Contact_at(self, index, value):
        self.Contact.insert(index, value)
    def replace_Contact_at(self, index, value):
        self.Contact[index] = value
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Account(self):
        return self.Account
    def set_Account(self, Account):
        self.Account = Account
    def add_Account(self, value):
        self.Account.append(value)
    def insert_Account_at(self, index, value):
        self.Account.insert(index, value)
    def replace_Account_at(self, index, value):
        self.Account[index] = value
    def get_Role(self):
        return self.Role
    def set_Role(self, Role):
        self.Role = Role
    def add_Role(self, value):
        self.Role.append(value)
    def insert_Role_at(self, index, value):
        self.Role.insert(index, value)
    def replace_Role_at(self, index, value):
        self.Role[index] = value
    def get_Logotype(self):
        return self.Logotype
    def set_Logotype(self, Logotype):
        self.Logotype = Logotype
    def add_Logotype(self, value):
        self.Logotype.append(value)
    def insert_Logotype_at(self, index, value):
        self.Logotype.insert(index, value)
    def replace_Logotype_at(self, index, value):
        self.Logotype[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['IOF', 'IOFRegion', 'NationalFederation', 'NationalRegion', 'Club', 'School', 'Company', 'Military', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.ShortName is not None or
            self.MediaName is not None or
            self.ParentOrganisationId is not None or
            self.Country is not None or
            self.Address or
            self.Contact or
            self.Position is not None or
            self.Account or
            self.Role or
            self.Logotype or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Organisation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Organisation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Organisation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Organisation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Organisation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Organisation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Organisation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.ShortName is not None:
            namespaceprefix_ = self.ShortName_nsprefix_ + ':' if (UseCapturedNS_ and self.ShortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShortName>%s</%sShortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ShortName), input_name='ShortName')), namespaceprefix_ , eol_))
        if self.MediaName is not None:
            namespaceprefix_ = self.MediaName_nsprefix_ + ':' if (UseCapturedNS_ and self.MediaName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMediaName>%s</%sMediaName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MediaName), input_name='MediaName')), namespaceprefix_ , eol_))
        if self.ParentOrganisationId is not None:
            namespaceprefix_ = self.ParentOrganisationId_nsprefix_ + ':' if (UseCapturedNS_ and self.ParentOrganisationId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentOrganisationId>%s</%sParentOrganisationId>%s' % (namespaceprefix_ , self.gds_format_integer(self.ParentOrganisationId, input_name='ParentOrganisationId'), namespaceprefix_ , eol_))
        if self.Country is not None:
            namespaceprefix_ = self.Country_nsprefix_ + ':' if (UseCapturedNS_ and self.Country_nsprefix_) else ''
            self.Country.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Country', pretty_print=pretty_print)
        for Address_ in self.Address:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            Address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        for Contact_ in self.Contact:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            Contact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            self.Position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        for Account_ in self.Account:
            namespaceprefix_ = self.Account_nsprefix_ + ':' if (UseCapturedNS_ and self.Account_nsprefix_) else ''
            Account_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Account', pretty_print=pretty_print)
        for Role_ in self.Role:
            namespaceprefix_ = self.Role_nsprefix_ + ':' if (UseCapturedNS_ and self.Role_nsprefix_) else ''
            Role_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Role', pretty_print=pretty_print)
        for Logotype_ in self.Logotype:
            namespaceprefix_ = self.Logotype_nsprefix_ + ':' if (UseCapturedNS_ and self.Logotype_nsprefix_) else ''
            Logotype_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Logotype', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType(self.type_)    # validate type typeType
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'ShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ShortName')
            value_ = self.gds_validate_string(value_, node, 'ShortName')
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
        elif nodeName_ == 'MediaName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MediaName')
            value_ = self.gds_validate_string(value_, node, 'MediaName')
            self.MediaName = value_
            self.MediaName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ParentOrganisationId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ParentOrganisationId')
            ival_ = self.gds_validate_integer(ival_, node, 'ParentOrganisationId')
            self.ParentOrganisationId = ival_
            self.ParentOrganisationId_nsprefix_ = child_.prefix
        elif nodeName_ == 'Country':
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Country = obj_
            obj_.original_tagname_ = 'Country'
        elif nodeName_ == 'Address':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address.append(obj_)
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact.append(obj_)
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Position':
            obj_ = GeoPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Account':
            obj_ = Account.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Account.append(obj_)
            obj_.original_tagname_ = 'Account'
        elif nodeName_ == 'Role':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Role.append(obj_)
            obj_.original_tagname_ = 'Role'
        elif nodeName_ == 'Logotype':
            obj_ = Image.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Logotype.append(obj_)
            obj_.original_tagname_ = 'Logotype'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Organisation


class Role(GeneratedsSuper):
    """A role defines a connection between a person and some kind of task,
    responsibility or engagement, e.g. being a course setter at an event.
    The type of role that the person has."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, Person=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Role)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Role.subclass:
            return Role.subclass(*args_, **kwargs_)
        else:
            return Role(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            self.Person is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Role', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Role')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Role':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Role')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Role', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Role'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Role', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
# end class Role


class Event(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Id=None, Name=None, StartTime=None, EndTime=None, Status=None, Classification=None, Form=None, Organiser=None, Official=None, Class=None, Race=None, EntryReceiver=None, Service=None, Account=None, URL=None, Information=None, Schedule=None, News=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.StartTime = StartTime
        self.StartTime_nsprefix_ = None
        self.EndTime = EndTime
        self.EndTime_nsprefix_ = None
        self.Status = Status
        self.validate_EventStatus(self.Status)
        self.Status_nsprefix_ = None
        self.Classification = Classification
        self.validate_EventClassification(self.Classification)
        self.Classification_nsprefix_ = None
        if Form is None:
            self.Form = []
        else:
            self.Form = Form
        self.Form_nsprefix_ = None
        if Organiser is None:
            self.Organiser = []
        else:
            self.Organiser = Organiser
        self.Organiser_nsprefix_ = None
        if Official is None:
            self.Official = []
        else:
            self.Official = Official
        self.Official_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if Race is None:
            self.Race = []
        else:
            self.Race = Race
        self.Race_nsprefix_ = None
        self.EntryReceiver = EntryReceiver
        self.EntryReceiver_nsprefix_ = None
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        self.Service_nsprefix_ = None
        if Account is None:
            self.Account = []
        else:
            self.Account = Account
        self.Account_nsprefix_ = None
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
        self.URL_nsprefix_ = None
        if Information is None:
            self.Information = []
        else:
            self.Information = Information
        self.Information_nsprefix_ = None
        if Schedule is None:
            self.Schedule = []
        else:
            self.Schedule = Schedule
        self.Schedule_nsprefix_ = None
        if News is None:
            self.News = []
        else:
            self.News = News
        self.News_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_EndTime(self):
        return self.EndTime
    def set_EndTime(self, EndTime):
        self.EndTime = EndTime
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Classification(self):
        return self.Classification
    def set_Classification(self, Classification):
        self.Classification = Classification
    def get_Form(self):
        return self.Form
    def set_Form(self, Form):
        self.Form = Form
    def add_Form(self, value):
        self.Form.append(value)
    def insert_Form_at(self, index, value):
        self.Form.insert(index, value)
    def replace_Form_at(self, index, value):
        self.Form[index] = value
    def get_Organiser(self):
        return self.Organiser
    def set_Organiser(self, Organiser):
        self.Organiser = Organiser
    def add_Organiser(self, value):
        self.Organiser.append(value)
    def insert_Organiser_at(self, index, value):
        self.Organiser.insert(index, value)
    def replace_Organiser_at(self, index, value):
        self.Organiser[index] = value
    def get_Official(self):
        return self.Official
    def set_Official(self, Official):
        self.Official = Official
    def add_Official(self, value):
        self.Official.append(value)
    def insert_Official_at(self, index, value):
        self.Official.insert(index, value)
    def replace_Official_at(self, index, value):
        self.Official[index] = value
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def add_Class(self, value):
        self.Class.append(value)
    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)
    def replace_Class_at(self, index, value):
        self.Class[index] = value
    def get_Race(self):
        return self.Race
    def set_Race(self, Race):
        self.Race = Race
    def add_Race(self, value):
        self.Race.append(value)
    def insert_Race_at(self, index, value):
        self.Race.insert(index, value)
    def replace_Race_at(self, index, value):
        self.Race[index] = value
    def get_EntryReceiver(self):
        return self.EntryReceiver
    def set_EntryReceiver(self, EntryReceiver):
        self.EntryReceiver = EntryReceiver
    def get_Service(self):
        return self.Service
    def set_Service(self, Service):
        self.Service = Service
    def add_Service(self, value):
        self.Service.append(value)
    def insert_Service_at(self, index, value):
        self.Service.insert(index, value)
    def replace_Service_at(self, index, value):
        self.Service[index] = value
    def get_Account(self):
        return self.Account
    def set_Account(self, Account):
        self.Account = Account
    def add_Account(self, value):
        self.Account.append(value)
    def insert_Account_at(self, index, value):
        self.Account.insert(index, value)
    def replace_Account_at(self, index, value):
        self.Account[index] = value
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def add_URL(self, value):
        self.URL.append(value)
    def insert_URL_at(self, index, value):
        self.URL.insert(index, value)
    def replace_URL_at(self, index, value):
        self.URL[index] = value
    def get_Information(self):
        return self.Information
    def set_Information(self, Information):
        self.Information = Information
    def add_Information(self, value):
        self.Information.append(value)
    def insert_Information_at(self, index, value):
        self.Information.insert(index, value)
    def replace_Information_at(self, index, value):
        self.Information[index] = value
    def get_Schedule(self):
        return self.Schedule
    def set_Schedule(self, Schedule):
        self.Schedule = Schedule
    def add_Schedule(self, value):
        self.Schedule.append(value)
    def insert_Schedule_at(self, index, value):
        self.Schedule.insert(index, value)
    def replace_Schedule_at(self, index, value):
        self.Schedule[index] = value
    def get_News(self):
        return self.News
    def set_News(self, News):
        self.News = News
    def add_News(self, value):
        self.News.append(value)
    def insert_News_at(self, index, value):
        self.News.insert(index, value)
    def replace_News_at(self, index, value):
        self.News[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_EventStatus(self, value):
        result = True
        # Validate type EventStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Planned', 'Applied', 'Proposed', 'Sanctioned', 'Canceled', 'Rescheduled']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_EventClassification(self, value):
        result = True
        # Validate type EventClassification, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['International', 'National', 'Regional', 'Local', 'Club']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventClassification' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_EventForm(self, value):
        result = True
        # Validate type EventForm, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Individual', 'Team', 'Relay']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventForm' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.Status is not None or
            self.Classification is not None or
            self.Form or
            self.Organiser or
            self.Official or
            self.Class or
            self.Race or
            self.EntryReceiver is not None or
            self.Service or
            self.Account or
            self.URL or
            self.Information or
            self.Schedule or
            self.News or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Event'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            self.StartTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartTime', pretty_print=pretty_print)
        if self.EndTime is not None:
            namespaceprefix_ = self.EndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.EndTime_nsprefix_) else ''
            self.EndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndTime', pretty_print=pretty_print)
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        if self.Classification is not None:
            namespaceprefix_ = self.Classification_nsprefix_ + ':' if (UseCapturedNS_ and self.Classification_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassification>%s</%sClassification>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Classification), input_name='Classification')), namespaceprefix_ , eol_))
        for Form_ in self.Form:
            namespaceprefix_ = self.Form_nsprefix_ + ':' if (UseCapturedNS_ and self.Form_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sForm>%s</%sForm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Form_), input_name='Form')), namespaceprefix_ , eol_))
        for Organiser_ in self.Organiser:
            namespaceprefix_ = self.Organiser_nsprefix_ + ':' if (UseCapturedNS_ and self.Organiser_nsprefix_) else ''
            Organiser_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organiser', pretty_print=pretty_print)
        for Official_ in self.Official:
            namespaceprefix_ = self.Official_nsprefix_ + ':' if (UseCapturedNS_ and self.Official_nsprefix_) else ''
            Official_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Official', pretty_print=pretty_print)
        for Class_ in self.Class:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            Class_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for Race_ in self.Race:
            namespaceprefix_ = self.Race_nsprefix_ + ':' if (UseCapturedNS_ and self.Race_nsprefix_) else ''
            Race_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Race', pretty_print=pretty_print)
        if self.EntryReceiver is not None:
            namespaceprefix_ = self.EntryReceiver_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryReceiver_nsprefix_) else ''
            self.EntryReceiver.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryReceiver', pretty_print=pretty_print)
        for Service_ in self.Service:
            namespaceprefix_ = self.Service_nsprefix_ + ':' if (UseCapturedNS_ and self.Service_nsprefix_) else ''
            Service_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Service', pretty_print=pretty_print)
        for Account_ in self.Account:
            namespaceprefix_ = self.Account_nsprefix_ + ':' if (UseCapturedNS_ and self.Account_nsprefix_) else ''
            Account_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Account', pretty_print=pretty_print)
        for URL_ in self.URL:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            URL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='URL', pretty_print=pretty_print)
        for Information_ in self.Information:
            namespaceprefix_ = self.Information_nsprefix_ + ':' if (UseCapturedNS_ and self.Information_nsprefix_) else ''
            Information_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Information', pretty_print=pretty_print)
        for Schedule_ in self.Schedule:
            namespaceprefix_ = self.Schedule_nsprefix_ + ':' if (UseCapturedNS_ and self.Schedule_nsprefix_) else ''
            Schedule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Schedule', pretty_print=pretty_print)
        for News_ in self.News:
            namespaceprefix_ = self.News_nsprefix_ + ':' if (UseCapturedNS_ and self.News_nsprefix_) else ''
            News_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='News', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            obj_ = DateAndOptionalTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartTime = obj_
            obj_.original_tagname_ = 'StartTime'
        elif nodeName_ == 'EndTime':
            obj_ = DateAndOptionalTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndTime = obj_
            obj_.original_tagname_ = 'EndTime'
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type EventStatus
            self.validate_EventStatus(self.Status)
        elif nodeName_ == 'Classification':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Classification')
            value_ = self.gds_validate_string(value_, node, 'Classification')
            self.Classification = value_
            self.Classification_nsprefix_ = child_.prefix
            # validate type EventClassification
            self.validate_EventClassification(self.Classification)
        elif nodeName_ == 'Form':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Form')
            value_ = self.gds_validate_string(value_, node, 'Form')
            self.Form.append(value_)
            self.Form_nsprefix_ = child_.prefix
            # validate type EventForm
            self.validate_EventForm(self.Form[-1])
        elif nodeName_ == 'Organiser':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organiser.append(obj_)
            obj_.original_tagname_ = 'Organiser'
        elif nodeName_ == 'Official':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Official.append(obj_)
            obj_.original_tagname_ = 'Official'
        elif nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class.append(obj_)
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Race':
            obj_ = Race.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Race.append(obj_)
            obj_.original_tagname_ = 'Race'
        elif nodeName_ == 'EntryReceiver':
            obj_ = EntryReceiver.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryReceiver = obj_
            obj_.original_tagname_ = 'EntryReceiver'
        elif nodeName_ == 'Service':
            obj_ = Service.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service.append(obj_)
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'Account':
            obj_ = Account.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Account.append(obj_)
            obj_.original_tagname_ = 'Account'
        elif nodeName_ == 'URL':
            obj_ = EventURL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.URL.append(obj_)
            obj_.original_tagname_ = 'URL'
        elif nodeName_ == 'Information':
            obj_ = InformationItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Information.append(obj_)
            obj_.original_tagname_ = 'Information'
        elif nodeName_ == 'Schedule':
            obj_ = Schedule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Schedule.append(obj_)
            obj_.original_tagname_ = 'Schedule'
        elif nodeName_ == 'News':
            obj_ = InformationItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.News.append(obj_)
            obj_.original_tagname_ = 'News'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Event


class EntryReceiver(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Address=None, Contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Address_nsprefix_ = None
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        self.Contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryReceiver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryReceiver.subclass:
            return EntryReceiver.subclass(*args_, **kwargs_)
        else:
            return EntryReceiver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def add_Address(self, value):
        self.Address.append(value)
    def insert_Address_at(self, index, value):
        self.Address.insert(index, value)
    def replace_Address_at(self, index, value):
        self.Address[index] = value
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def add_Contact(self, value):
        self.Contact.append(value)
    def insert_Contact_at(self, index, value):
        self.Contact.insert(index, value)
    def replace_Contact_at(self, index, value):
        self.Contact[index] = value
    def hasContent_(self):
        if (
            self.Address or
            self.Contact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EntryReceiver', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryReceiver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntryReceiver':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntryReceiver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntryReceiver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EntryReceiver'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='EntryReceiver', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Address_ in self.Address:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            Address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        for Contact_ in self.Contact:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            Contact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Address':
            obj_ = Address.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address.append(obj_)
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact.append(obj_)
            obj_.original_tagname_ = 'Contact'
# end class EntryReceiver


class Race(GeneratedsSuper):
    """An event consists of a number of races. The number is equal to the
    number of times a competitor should start."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, RaceNumber=None, Name=None, StartTime=None, EndTime=None, Status=None, Classification=None, Position=None, Discipline=None, Organiser=None, Official=None, Service=None, URL=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.RaceNumber = RaceNumber
        self.RaceNumber_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.StartTime = StartTime
        self.StartTime_nsprefix_ = None
        self.EndTime = EndTime
        self.EndTime_nsprefix_ = None
        self.Status = Status
        self.validate_EventStatus(self.Status)
        self.Status_nsprefix_ = None
        self.Classification = Classification
        self.validate_EventClassification(self.Classification)
        self.Classification_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        if Discipline is None:
            self.Discipline = []
        else:
            self.Discipline = Discipline
        self.Discipline_nsprefix_ = None
        if Organiser is None:
            self.Organiser = []
        else:
            self.Organiser = Organiser
        self.Organiser_nsprefix_ = None
        if Official is None:
            self.Official = []
        else:
            self.Official = Official
        self.Official_nsprefix_ = None
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        self.Service_nsprefix_ = None
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
        self.URL_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Race)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Race.subclass:
            return Race.subclass(*args_, **kwargs_)
        else:
            return Race(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RaceNumber(self):
        return self.RaceNumber
    def set_RaceNumber(self, RaceNumber):
        self.RaceNumber = RaceNumber
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_EndTime(self):
        return self.EndTime
    def set_EndTime(self, EndTime):
        self.EndTime = EndTime
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Classification(self):
        return self.Classification
    def set_Classification(self, Classification):
        self.Classification = Classification
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Discipline(self):
        return self.Discipline
    def set_Discipline(self, Discipline):
        self.Discipline = Discipline
    def add_Discipline(self, value):
        self.Discipline.append(value)
    def insert_Discipline_at(self, index, value):
        self.Discipline.insert(index, value)
    def replace_Discipline_at(self, index, value):
        self.Discipline[index] = value
    def get_Organiser(self):
        return self.Organiser
    def set_Organiser(self, Organiser):
        self.Organiser = Organiser
    def add_Organiser(self, value):
        self.Organiser.append(value)
    def insert_Organiser_at(self, index, value):
        self.Organiser.insert(index, value)
    def replace_Organiser_at(self, index, value):
        self.Organiser[index] = value
    def get_Official(self):
        return self.Official
    def set_Official(self, Official):
        self.Official = Official
    def add_Official(self, value):
        self.Official.append(value)
    def insert_Official_at(self, index, value):
        self.Official.insert(index, value)
    def replace_Official_at(self, index, value):
        self.Official[index] = value
    def get_Service(self):
        return self.Service
    def set_Service(self, Service):
        self.Service = Service
    def add_Service(self, value):
        self.Service.append(value)
    def insert_Service_at(self, index, value):
        self.Service.insert(index, value)
    def replace_Service_at(self, index, value):
        self.Service[index] = value
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def add_URL(self, value):
        self.URL.append(value)
    def insert_URL_at(self, index, value):
        self.URL.insert(index, value)
    def replace_URL_at(self, index, value):
        self.URL[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_EventStatus(self, value):
        result = True
        # Validate type EventStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Planned', 'Applied', 'Proposed', 'Sanctioned', 'Canceled', 'Rescheduled']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_EventClassification(self, value):
        result = True
        # Validate type EventClassification, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['International', 'National', 'Regional', 'Local', 'Club']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventClassification' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_RaceDiscipline(self, value):
        result = True
        # Validate type RaceDiscipline, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Sprint', 'Middle', 'Long', 'Ultralong', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RaceDiscipline' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.RaceNumber is not None or
            self.Name is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.Status is not None or
            self.Classification is not None or
            self.Position is not None or
            self.Discipline or
            self.Organiser or
            self.Official or
            self.Service or
            self.URL or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Race', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Race')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Race':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Race')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Race', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Race'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Race', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RaceNumber is not None:
            namespaceprefix_ = self.RaceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.RaceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRaceNumber>%s</%sRaceNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.RaceNumber, input_name='RaceNumber'), namespaceprefix_ , eol_))
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            self.StartTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartTime', pretty_print=pretty_print)
        if self.EndTime is not None:
            namespaceprefix_ = self.EndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.EndTime_nsprefix_) else ''
            self.EndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndTime', pretty_print=pretty_print)
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        if self.Classification is not None:
            namespaceprefix_ = self.Classification_nsprefix_ + ':' if (UseCapturedNS_ and self.Classification_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassification>%s</%sClassification>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Classification), input_name='Classification')), namespaceprefix_ , eol_))
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            self.Position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        for Discipline_ in self.Discipline:
            namespaceprefix_ = self.Discipline_nsprefix_ + ':' if (UseCapturedNS_ and self.Discipline_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscipline>%s</%sDiscipline>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Discipline_), input_name='Discipline')), namespaceprefix_ , eol_))
        for Organiser_ in self.Organiser:
            namespaceprefix_ = self.Organiser_nsprefix_ + ':' if (UseCapturedNS_ and self.Organiser_nsprefix_) else ''
            Organiser_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organiser', pretty_print=pretty_print)
        for Official_ in self.Official:
            namespaceprefix_ = self.Official_nsprefix_ + ':' if (UseCapturedNS_ and self.Official_nsprefix_) else ''
            Official_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Official', pretty_print=pretty_print)
        for Service_ in self.Service:
            namespaceprefix_ = self.Service_nsprefix_ + ':' if (UseCapturedNS_ and self.Service_nsprefix_) else ''
            Service_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Service', pretty_print=pretty_print)
        for URL_ in self.URL:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            URL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='URL', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RaceNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RaceNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'RaceNumber')
            self.RaceNumber = ival_
            self.RaceNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            obj_ = DateAndOptionalTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartTime = obj_
            obj_.original_tagname_ = 'StartTime'
        elif nodeName_ == 'EndTime':
            obj_ = DateAndOptionalTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndTime = obj_
            obj_.original_tagname_ = 'EndTime'
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type EventStatus
            self.validate_EventStatus(self.Status)
        elif nodeName_ == 'Classification':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Classification')
            value_ = self.gds_validate_string(value_, node, 'Classification')
            self.Classification = value_
            self.Classification_nsprefix_ = child_.prefix
            # validate type EventClassification
            self.validate_EventClassification(self.Classification)
        elif nodeName_ == 'Position':
            obj_ = GeoPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Discipline':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Discipline')
            value_ = self.gds_validate_string(value_, node, 'Discipline')
            self.Discipline.append(value_)
            self.Discipline_nsprefix_ = child_.prefix
            # validate type RaceDiscipline
            self.validate_RaceDiscipline(self.Discipline[-1])
        elif nodeName_ == 'Organiser':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organiser.append(obj_)
            obj_.original_tagname_ = 'Organiser'
        elif nodeName_ == 'Official':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Official.append(obj_)
            obj_.original_tagname_ = 'Official'
        elif nodeName_ == 'Service':
            obj_ = Service.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service.append(obj_)
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'URL':
            obj_ = EventURL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.URL.append(obj_)
            obj_.original_tagname_ = 'URL'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Race


class EventURL(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventURL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventURL.subclass:
            return EventURL.subclass(*args_, **kwargs_)
        else:
            return EventURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType1(self, value):
        # Validate type typeType1, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Website', 'StartList', 'ResultList', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventURL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventURL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventURL':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventURL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventURL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventURL'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventURL', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType1(self.type_)    # validate type typeType1
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EventURL


class Schedule(GeneratedsSuper):
    """Defines the schedule of sub-events that comprise the entire orienteering
    event, e.g. banquets, social events and awards ceremonies."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, StartTime=None, EndTime=None, Name=None, Venue=None, Position=None, Details=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.StartTime_nsprefix_ = None
        if isinstance(EndTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EndTime
        self.EndTime = initvalue_
        self.EndTime_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Venue = Venue
        self.Venue_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        self.Details = Details
        self.Details_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Schedule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Schedule.subclass:
            return Schedule.subclass(*args_, **kwargs_)
        else:
            return Schedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_EndTime(self):
        return self.EndTime
    def set_EndTime(self, EndTime):
        self.EndTime = EndTime
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Venue(self):
        return self.Venue
    def set_Venue(self, Venue):
        self.Venue = Venue
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.StartTime is not None or
            self.EndTime is not None or
            self.Name is not None or
            self.Venue is not None or
            self.Position is not None or
            self.Details is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Schedule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Schedule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Schedule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Schedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Schedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Schedule'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Schedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespaceprefix_ , eol_))
        if self.EndTime is not None:
            namespaceprefix_ = self.EndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.EndTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.EndTime, input_name='EndTime'), namespaceprefix_ , eol_))
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.Venue is not None:
            namespaceprefix_ = self.Venue_nsprefix_ + ':' if (UseCapturedNS_ and self.Venue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVenue>%s</%sVenue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Venue), input_name='Venue')), namespaceprefix_ , eol_))
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            self.Position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Details), input_name='Details')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
            self.StartTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'EndTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EndTime = dval_
            self.EndTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Venue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Venue')
            value_ = self.gds_validate_string(value_, node, 'Venue')
            self.Venue = value_
            self.Venue_nsprefix_ = child_.prefix
        elif nodeName_ == 'Position':
            obj_ = GeoPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Details':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Details')
            value_ = self.gds_validate_string(value_, node, 'Details')
            self.Details = value_
            self.Details_nsprefix_ = child_.prefix
# end class Schedule


class InformationItem(GeneratedsSuper):
    """Defines a general-purpose information object containing a title and
    content."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Title=None, Content=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Title = Title
        self.Title_nsprefix_ = None
        self.Content = Content
        self.Content_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformationItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformationItem.subclass:
            return InformationItem.subclass(*args_, **kwargs_)
        else:
            return InformationItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Title(self):
        return self.Title
    def set_Title(self, Title):
        self.Title = Title
    def get_Content(self):
        return self.Content
    def set_Content(self, Content):
        self.Content = Content
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='InformationItem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InformationItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InformationItem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InformationItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InformationItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InformationItem'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='InformationItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespaceprefix_ , eol_))
        if self.Content is not None:
            namespaceprefix_ = self.Content_nsprefix_ + ':' if (UseCapturedNS_ and self.Content_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContent>%s</%sContent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Content), input_name='Content')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Title')
            value_ = self.gds_validate_string(value_, node, 'Title')
            self.Title = value_
            self.Title_nsprefix_ = child_.prefix
        elif nodeName_ == 'Content':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Content')
            value_ = self.gds_validate_string(value_, node, 'Content')
            self.Content = value_
            self.Content_nsprefix_ = child_.prefix
# end class InformationItem


class Class(GeneratedsSuper):
    """Defines a class in an event.
    The lowest allowed age for a competitor taking part in the class.
    The highest allowed age for a competitor taking part in the class.
    The minimum number of members in a team taking part in the class, if the
    class is a team class.
    The maximum number of members in a team taking part in the class, if the
    class is a team class.
    The lowest allowed age sum of the team members for a team taking part in
    the class.
    The highest allowed age sum of the team members for a team taking part in
    the class.
    The number of competitors in the class. A competitor corresponds to a
    person (if an individual event) or a team (if a team or relay event).
    The maximum number of competitors that are allowed to take part in the
    class. A competitor corresponds to a person (if an individual event) or
    a team (if a team or relay event). If the maximum number of competitors
    varies between races in a multi-day event, use the
    maxNumberOfCompetitors attribute in the RaceClass element.
    Defines the kind of information to include in the result list, and how to
    sort it. For example, the result list of a beginner's class may include
    just "finished" or "did not finish" instead of the actual times."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, minAge=None, maxAge=None, sex='B', minNumberOfTeamMembers=1, maxNumberOfTeamMembers=1, minTeamAge=None, maxTeamAge=None, numberOfCompetitors=None, maxNumberOfCompetitors=None, resultListMode='Default', modifyTime=None, Id=None, Name=None, ShortName=None, ClassType=None, Leg=None, TeamFee=None, Fee=None, Status='Normal', RaceClass=None, TooFewEntriesSubstituteClass=None, TooManyEntriesSubstituteClass=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minAge = _cast(int, minAge)
        self.minAge_nsprefix_ = None
        self.maxAge = _cast(int, maxAge)
        self.maxAge_nsprefix_ = None
        self.sex = _cast(None, sex)
        self.sex_nsprefix_ = None
        self.minNumberOfTeamMembers = _cast(int, minNumberOfTeamMembers)
        self.minNumberOfTeamMembers_nsprefix_ = None
        self.maxNumberOfTeamMembers = _cast(int, maxNumberOfTeamMembers)
        self.maxNumberOfTeamMembers_nsprefix_ = None
        self.minTeamAge = _cast(int, minTeamAge)
        self.minTeamAge_nsprefix_ = None
        self.maxTeamAge = _cast(int, maxTeamAge)
        self.maxTeamAge_nsprefix_ = None
        self.numberOfCompetitors = _cast(int, numberOfCompetitors)
        self.numberOfCompetitors_nsprefix_ = None
        self.maxNumberOfCompetitors = _cast(int, maxNumberOfCompetitors)
        self.maxNumberOfCompetitors_nsprefix_ = None
        self.resultListMode = _cast(None, resultListMode)
        self.resultListMode_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.ShortName = ShortName
        self.ShortName_nsprefix_ = None
        if ClassType is None:
            self.ClassType = []
        else:
            self.ClassType = ClassType
        self.ClassType_nsprefix_ = None
        if Leg is None:
            self.Leg = []
        else:
            self.Leg = Leg
        self.Leg_nsprefix_ = None
        if TeamFee is None:
            self.TeamFee = []
        else:
            self.TeamFee = TeamFee
        self.TeamFee_nsprefix_ = None
        if Fee is None:
            self.Fee = []
        else:
            self.Fee = Fee
        self.Fee_nsprefix_ = None
        self.Status = Status
        self.validate_EventClassStatus(self.Status)
        self.Status_nsprefix_ = None
        if RaceClass is None:
            self.RaceClass = []
        else:
            self.RaceClass = RaceClass
        self.RaceClass_nsprefix_ = None
        self.TooFewEntriesSubstituteClass = TooFewEntriesSubstituteClass
        self.TooFewEntriesSubstituteClass_nsprefix_ = None
        self.TooManyEntriesSubstituteClass = TooManyEntriesSubstituteClass
        self.TooManyEntriesSubstituteClass_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Class)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Class.subclass:
            return Class.subclass(*args_, **kwargs_)
        else:
            return Class(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_ShortName(self):
        return self.ShortName
    def set_ShortName(self, ShortName):
        self.ShortName = ShortName
    def get_ClassType(self):
        return self.ClassType
    def set_ClassType(self, ClassType):
        self.ClassType = ClassType
    def add_ClassType(self, value):
        self.ClassType.append(value)
    def insert_ClassType_at(self, index, value):
        self.ClassType.insert(index, value)
    def replace_ClassType_at(self, index, value):
        self.ClassType[index] = value
    def get_Leg(self):
        return self.Leg
    def set_Leg(self, Leg):
        self.Leg = Leg
    def add_Leg(self, value):
        self.Leg.append(value)
    def insert_Leg_at(self, index, value):
        self.Leg.insert(index, value)
    def replace_Leg_at(self, index, value):
        self.Leg[index] = value
    def get_TeamFee(self):
        return self.TeamFee
    def set_TeamFee(self, TeamFee):
        self.TeamFee = TeamFee
    def add_TeamFee(self, value):
        self.TeamFee.append(value)
    def insert_TeamFee_at(self, index, value):
        self.TeamFee.insert(index, value)
    def replace_TeamFee_at(self, index, value):
        self.TeamFee[index] = value
    def get_Fee(self):
        return self.Fee
    def set_Fee(self, Fee):
        self.Fee = Fee
    def add_Fee(self, value):
        self.Fee.append(value)
    def insert_Fee_at(self, index, value):
        self.Fee.insert(index, value)
    def replace_Fee_at(self, index, value):
        self.Fee[index] = value
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_RaceClass(self):
        return self.RaceClass
    def set_RaceClass(self, RaceClass):
        self.RaceClass = RaceClass
    def add_RaceClass(self, value):
        self.RaceClass.append(value)
    def insert_RaceClass_at(self, index, value):
        self.RaceClass.insert(index, value)
    def replace_RaceClass_at(self, index, value):
        self.RaceClass[index] = value
    def get_TooFewEntriesSubstituteClass(self):
        return self.TooFewEntriesSubstituteClass
    def set_TooFewEntriesSubstituteClass(self, TooFewEntriesSubstituteClass):
        self.TooFewEntriesSubstituteClass = TooFewEntriesSubstituteClass
    def get_TooManyEntriesSubstituteClass(self):
        return self.TooManyEntriesSubstituteClass
    def set_TooManyEntriesSubstituteClass(self, TooManyEntriesSubstituteClass):
        self.TooManyEntriesSubstituteClass = TooManyEntriesSubstituteClass
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_minAge(self):
        return self.minAge
    def set_minAge(self, minAge):
        self.minAge = minAge
    def get_maxAge(self):
        return self.maxAge
    def set_maxAge(self, maxAge):
        self.maxAge = maxAge
    def get_sex(self):
        return self.sex
    def set_sex(self, sex):
        self.sex = sex
    def get_minNumberOfTeamMembers(self):
        return self.minNumberOfTeamMembers
    def set_minNumberOfTeamMembers(self, minNumberOfTeamMembers):
        self.minNumberOfTeamMembers = minNumberOfTeamMembers
    def get_maxNumberOfTeamMembers(self):
        return self.maxNumberOfTeamMembers
    def set_maxNumberOfTeamMembers(self, maxNumberOfTeamMembers):
        self.maxNumberOfTeamMembers = maxNumberOfTeamMembers
    def get_minTeamAge(self):
        return self.minTeamAge
    def set_minTeamAge(self, minTeamAge):
        self.minTeamAge = minTeamAge
    def get_maxTeamAge(self):
        return self.maxTeamAge
    def set_maxTeamAge(self, maxTeamAge):
        self.maxTeamAge = maxTeamAge
    def get_numberOfCompetitors(self):
        return self.numberOfCompetitors
    def set_numberOfCompetitors(self, numberOfCompetitors):
        self.numberOfCompetitors = numberOfCompetitors
    def get_maxNumberOfCompetitors(self):
        return self.maxNumberOfCompetitors
    def set_maxNumberOfCompetitors(self, maxNumberOfCompetitors):
        self.maxNumberOfCompetitors = maxNumberOfCompetitors
    def get_resultListMode(self):
        return self.resultListMode
    def set_resultListMode(self, resultListMode):
        self.resultListMode = resultListMode
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_EventClassStatus(self, value):
        result = True
        # Validate type EventClassStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Normal', 'Divided', 'Joined', 'Invalidated', 'InvalidatedNoFee']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EventClassStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_sexType2(self, value):
        # Validate type sexType2, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['B', 'F', 'M']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on sexType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_resultListModeType(self, value):
        # Validate type resultListModeType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Default', 'Unordered', 'UnorderedNoTimes']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resultListModeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.ShortName is not None or
            self.ClassType or
            self.Leg or
            self.TeamFee or
            self.Fee or
            self.Status != "Normal" or
            self.RaceClass or
            self.TooFewEntriesSubstituteClass is not None or
            self.TooManyEntriesSubstituteClass is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Class', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Class')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Class':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Class')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Class', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Class'):
        if self.minAge is not None and 'minAge' not in already_processed:
            already_processed.add('minAge')
            outfile.write(' minAge="%s"' % self.gds_format_integer(self.minAge, input_name='minAge'))
        if self.maxAge is not None and 'maxAge' not in already_processed:
            already_processed.add('maxAge')
            outfile.write(' maxAge="%s"' % self.gds_format_integer(self.maxAge, input_name='maxAge'))
        if self.sex != "B" and 'sex' not in already_processed:
            already_processed.add('sex')
            outfile.write(' sex=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sex), input_name='sex')), ))
        if self.minNumberOfTeamMembers != 1 and 'minNumberOfTeamMembers' not in already_processed:
            already_processed.add('minNumberOfTeamMembers')
            outfile.write(' minNumberOfTeamMembers="%s"' % self.gds_format_integer(self.minNumberOfTeamMembers, input_name='minNumberOfTeamMembers'))
        if self.maxNumberOfTeamMembers != 1 and 'maxNumberOfTeamMembers' not in already_processed:
            already_processed.add('maxNumberOfTeamMembers')
            outfile.write(' maxNumberOfTeamMembers="%s"' % self.gds_format_integer(self.maxNumberOfTeamMembers, input_name='maxNumberOfTeamMembers'))
        if self.minTeamAge is not None and 'minTeamAge' not in already_processed:
            already_processed.add('minTeamAge')
            outfile.write(' minTeamAge="%s"' % self.gds_format_integer(self.minTeamAge, input_name='minTeamAge'))
        if self.maxTeamAge is not None and 'maxTeamAge' not in already_processed:
            already_processed.add('maxTeamAge')
            outfile.write(' maxTeamAge="%s"' % self.gds_format_integer(self.maxTeamAge, input_name='maxTeamAge'))
        if self.numberOfCompetitors is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            outfile.write(' numberOfCompetitors="%s"' % self.gds_format_integer(self.numberOfCompetitors, input_name='numberOfCompetitors'))
        if self.maxNumberOfCompetitors is not None and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            outfile.write(' maxNumberOfCompetitors="%s"' % self.gds_format_integer(self.maxNumberOfCompetitors, input_name='maxNumberOfCompetitors'))
        if self.resultListMode != "Default" and 'resultListMode' not in already_processed:
            already_processed.add('resultListMode')
            outfile.write(' resultListMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resultListMode), input_name='resultListMode')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Class', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.ShortName is not None:
            namespaceprefix_ = self.ShortName_nsprefix_ + ':' if (UseCapturedNS_ and self.ShortName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShortName>%s</%sShortName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ShortName), input_name='ShortName')), namespaceprefix_ , eol_))
        for ClassType_ in self.ClassType:
            namespaceprefix_ = self.ClassType_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassType_nsprefix_) else ''
            ClassType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassType', pretty_print=pretty_print)
        for Leg_ in self.Leg:
            namespaceprefix_ = self.Leg_nsprefix_ + ':' if (UseCapturedNS_ and self.Leg_nsprefix_) else ''
            Leg_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Leg', pretty_print=pretty_print)
        for TeamFee_ in self.TeamFee:
            namespaceprefix_ = self.TeamFee_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamFee_nsprefix_) else ''
            TeamFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamFee', pretty_print=pretty_print)
        for Fee_ in self.Fee:
            namespaceprefix_ = self.Fee_nsprefix_ + ':' if (UseCapturedNS_ and self.Fee_nsprefix_) else ''
            Fee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Fee', pretty_print=pretty_print)
        if self.Status != "Normal":
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        for RaceClass_ in self.RaceClass:
            namespaceprefix_ = self.RaceClass_nsprefix_ + ':' if (UseCapturedNS_ and self.RaceClass_nsprefix_) else ''
            RaceClass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RaceClass', pretty_print=pretty_print)
        if self.TooFewEntriesSubstituteClass is not None:
            namespaceprefix_ = self.TooFewEntriesSubstituteClass_nsprefix_ + ':' if (UseCapturedNS_ and self.TooFewEntriesSubstituteClass_nsprefix_) else ''
            self.TooFewEntriesSubstituteClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TooFewEntriesSubstituteClass', pretty_print=pretty_print)
        if self.TooManyEntriesSubstituteClass is not None:
            namespaceprefix_ = self.TooManyEntriesSubstituteClass_nsprefix_ + ':' if (UseCapturedNS_ and self.TooManyEntriesSubstituteClass_nsprefix_) else ''
            self.TooManyEntriesSubstituteClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TooManyEntriesSubstituteClass', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minAge', node)
        if value is not None and 'minAge' not in already_processed:
            already_processed.add('minAge')
            self.minAge = self.gds_parse_integer(value, node, 'minAge')
        value = find_attr_value_('maxAge', node)
        if value is not None and 'maxAge' not in already_processed:
            already_processed.add('maxAge')
            self.maxAge = self.gds_parse_integer(value, node, 'maxAge')
        value = find_attr_value_('sex', node)
        if value is not None and 'sex' not in already_processed:
            already_processed.add('sex')
            self.sex = value
            self.validate_sexType2(self.sex)    # validate type sexType2
        value = find_attr_value_('minNumberOfTeamMembers', node)
        if value is not None and 'minNumberOfTeamMembers' not in already_processed:
            already_processed.add('minNumberOfTeamMembers')
            self.minNumberOfTeamMembers = self.gds_parse_integer(value, node, 'minNumberOfTeamMembers')
        value = find_attr_value_('maxNumberOfTeamMembers', node)
        if value is not None and 'maxNumberOfTeamMembers' not in already_processed:
            already_processed.add('maxNumberOfTeamMembers')
            self.maxNumberOfTeamMembers = self.gds_parse_integer(value, node, 'maxNumberOfTeamMembers')
        value = find_attr_value_('minTeamAge', node)
        if value is not None and 'minTeamAge' not in already_processed:
            already_processed.add('minTeamAge')
            self.minTeamAge = self.gds_parse_integer(value, node, 'minTeamAge')
        value = find_attr_value_('maxTeamAge', node)
        if value is not None and 'maxTeamAge' not in already_processed:
            already_processed.add('maxTeamAge')
            self.maxTeamAge = self.gds_parse_integer(value, node, 'maxTeamAge')
        value = find_attr_value_('numberOfCompetitors', node)
        if value is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            self.numberOfCompetitors = self.gds_parse_integer(value, node, 'numberOfCompetitors')
        value = find_attr_value_('maxNumberOfCompetitors', node)
        if value is not None and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            self.maxNumberOfCompetitors = self.gds_parse_integer(value, node, 'maxNumberOfCompetitors')
        value = find_attr_value_('resultListMode', node)
        if value is not None and 'resultListMode' not in already_processed:
            already_processed.add('resultListMode')
            self.resultListMode = value
            self.validate_resultListModeType(self.resultListMode)    # validate type resultListModeType
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'ShortName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ShortName')
            value_ = self.gds_validate_string(value_, node, 'ShortName')
            self.ShortName = value_
            self.ShortName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassType':
            obj_ = ClassType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassType.append(obj_)
            obj_.original_tagname_ = 'ClassType'
        elif nodeName_ == 'Leg':
            obj_ = Leg.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Leg.append(obj_)
            obj_.original_tagname_ = 'Leg'
        elif nodeName_ == 'TeamFee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamFee.append(obj_)
            obj_.original_tagname_ = 'TeamFee'
        elif nodeName_ == 'Fee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Fee.append(obj_)
            obj_.original_tagname_ = 'Fee'
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type EventClassStatus
            self.validate_EventClassStatus(self.Status)
        elif nodeName_ == 'RaceClass':
            obj_ = RaceClass.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RaceClass.append(obj_)
            obj_.original_tagname_ = 'RaceClass'
        elif nodeName_ == 'TooFewEntriesSubstituteClass':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TooFewEntriesSubstituteClass = obj_
            obj_.original_tagname_ = 'TooFewEntriesSubstituteClass'
        elif nodeName_ == 'TooManyEntriesSubstituteClass':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TooManyEntriesSubstituteClass = obj_
            obj_.original_tagname_ = 'TooManyEntriesSubstituteClass'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Class


class ClassType(GeneratedsSuper):
    """Defines a class type, which is used to group classes in categories."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Id=None, Name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassType.subclass:
            return ClassType.subclass(*args_, **kwargs_)
        else:
            return ClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassType'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
# end class ClassType


class RaceClass(GeneratedsSuper):
    """Information about a class with respect to a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1.
    The maximum number of competitors that are allowed to take part in the race
    class. A competitor corresponds to a person (if an individual event) or
    a team (if a team or relay event). This attribute overrides the
    maxNumberOfCompetitors attribute in the Class element."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, maxNumberOfCompetitors=None, modifyTime=None, PunchingSystem=None, TeamFee=None, Fee=None, FirstStart=None, Status=None, Course=None, OnlineControl=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.maxNumberOfCompetitors = _cast(int, maxNumberOfCompetitors)
        self.maxNumberOfCompetitors_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        if PunchingSystem is None:
            self.PunchingSystem = []
        else:
            self.PunchingSystem = PunchingSystem
        self.PunchingSystem_nsprefix_ = None
        if TeamFee is None:
            self.TeamFee = []
        else:
            self.TeamFee = TeamFee
        self.TeamFee_nsprefix_ = None
        if Fee is None:
            self.Fee = []
        else:
            self.Fee = Fee
        self.Fee_nsprefix_ = None
        if isinstance(FirstStart, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FirstStart, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = FirstStart
        self.FirstStart = initvalue_
        self.FirstStart_nsprefix_ = None
        self.Status = Status
        self.validate_RaceClassStatus(self.Status)
        self.Status_nsprefix_ = None
        if Course is None:
            self.Course = []
        else:
            self.Course = Course
        self.Course_nsprefix_ = None
        if OnlineControl is None:
            self.OnlineControl = []
        else:
            self.OnlineControl = OnlineControl
        self.OnlineControl_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RaceClass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RaceClass.subclass:
            return RaceClass.subclass(*args_, **kwargs_)
        else:
            return RaceClass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PunchingSystem(self):
        return self.PunchingSystem
    def set_PunchingSystem(self, PunchingSystem):
        self.PunchingSystem = PunchingSystem
    def add_PunchingSystem(self, value):
        self.PunchingSystem.append(value)
    def insert_PunchingSystem_at(self, index, value):
        self.PunchingSystem.insert(index, value)
    def replace_PunchingSystem_at(self, index, value):
        self.PunchingSystem[index] = value
    def get_TeamFee(self):
        return self.TeamFee
    def set_TeamFee(self, TeamFee):
        self.TeamFee = TeamFee
    def add_TeamFee(self, value):
        self.TeamFee.append(value)
    def insert_TeamFee_at(self, index, value):
        self.TeamFee.insert(index, value)
    def replace_TeamFee_at(self, index, value):
        self.TeamFee[index] = value
    def get_Fee(self):
        return self.Fee
    def set_Fee(self, Fee):
        self.Fee = Fee
    def add_Fee(self, value):
        self.Fee.append(value)
    def insert_Fee_at(self, index, value):
        self.Fee.insert(index, value)
    def replace_Fee_at(self, index, value):
        self.Fee[index] = value
    def get_FirstStart(self):
        return self.FirstStart
    def set_FirstStart(self, FirstStart):
        self.FirstStart = FirstStart
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def add_Course(self, value):
        self.Course.append(value)
    def insert_Course_at(self, index, value):
        self.Course.insert(index, value)
    def replace_Course_at(self, index, value):
        self.Course[index] = value
    def get_OnlineControl(self):
        return self.OnlineControl
    def set_OnlineControl(self, OnlineControl):
        self.OnlineControl = OnlineControl
    def add_OnlineControl(self, value):
        self.OnlineControl.append(value)
    def insert_OnlineControl_at(self, index, value):
        self.OnlineControl.insert(index, value)
    def replace_OnlineControl_at(self, index, value):
        self.OnlineControl[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def get_maxNumberOfCompetitors(self):
        return self.maxNumberOfCompetitors
    def set_maxNumberOfCompetitors(self, maxNumberOfCompetitors):
        self.maxNumberOfCompetitors = maxNumberOfCompetitors
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_RaceClassStatus(self, value):
        result = True
        # Validate type RaceClassStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['StartTimesNotAllocated', 'StartTimesAllocated', 'NotUsed', 'Completed', 'Invalidated', 'InvalidatedNoFee']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RaceClassStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.PunchingSystem or
            self.TeamFee or
            self.Fee or
            self.FirstStart is not None or
            self.Status is not None or
            self.Course or
            self.OnlineControl or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='RaceClass', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RaceClass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RaceClass':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RaceClass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RaceClass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RaceClass'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
        if self.maxNumberOfCompetitors is not None and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            outfile.write(' maxNumberOfCompetitors="%s"' % self.gds_format_integer(self.maxNumberOfCompetitors, input_name='maxNumberOfCompetitors'))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='RaceClass', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PunchingSystem_ in self.PunchingSystem:
            namespaceprefix_ = self.PunchingSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.PunchingSystem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPunchingSystem>%s</%sPunchingSystem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(PunchingSystem_), input_name='PunchingSystem')), namespaceprefix_ , eol_))
        for TeamFee_ in self.TeamFee:
            namespaceprefix_ = self.TeamFee_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamFee_nsprefix_) else ''
            TeamFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamFee', pretty_print=pretty_print)
        for Fee_ in self.Fee:
            namespaceprefix_ = self.Fee_nsprefix_ + ':' if (UseCapturedNS_ and self.Fee_nsprefix_) else ''
            Fee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Fee', pretty_print=pretty_print)
        if self.FirstStart is not None:
            namespaceprefix_ = self.FirstStart_nsprefix_ + ':' if (UseCapturedNS_ and self.FirstStart_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirstStart>%s</%sFirstStart>%s' % (namespaceprefix_ , self.gds_format_datetime(self.FirstStart, input_name='FirstStart'), namespaceprefix_ , eol_))
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        for Course_ in self.Course:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            Course_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for OnlineControl_ in self.OnlineControl:
            namespaceprefix_ = self.OnlineControl_nsprefix_ + ':' if (UseCapturedNS_ and self.OnlineControl_nsprefix_) else ''
            OnlineControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OnlineControl', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
        value = find_attr_value_('maxNumberOfCompetitors', node)
        if value is not None and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            self.maxNumberOfCompetitors = self.gds_parse_integer(value, node, 'maxNumberOfCompetitors')
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PunchingSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PunchingSystem')
            value_ = self.gds_validate_string(value_, node, 'PunchingSystem')
            self.PunchingSystem.append(value_)
            self.PunchingSystem_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamFee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamFee.append(obj_)
            obj_.original_tagname_ = 'TeamFee'
        elif nodeName_ == 'Fee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Fee.append(obj_)
            obj_.original_tagname_ = 'Fee'
        elif nodeName_ == 'FirstStart':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.FirstStart = dval_
            self.FirstStart_nsprefix_ = child_.prefix
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type RaceClassStatus
            self.validate_RaceClassStatus(self.Status)
        elif nodeName_ == 'Course':
            class_obj_ = self.get_class_obj_(child_, SimpleCourse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course.append(obj_)
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'OnlineControl':
            obj_ = Control.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnlineControl.append(obj_)
            obj_.original_tagname_ = 'OnlineControl'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class RaceClass


class Fee(GeneratedsSuper):
    """A fee that applies when entering a class at a race or ordering a
    service.
    The type of fee."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='Normal', modifyTime=None, Id=None, Name=None, Amount=None, TaxableAmount=None, Percentage=None, TaxablePercentage=None, ValidFromTime=None, ValidToTime=None, FromDateOfBirth=None, ToDateOfBirth=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        self.Amount = Amount
        self.Amount_nsprefix_ = None
        self.TaxableAmount = TaxableAmount
        self.TaxableAmount_nsprefix_ = None
        self.Percentage = Percentage
        self.Percentage_nsprefix_ = None
        self.TaxablePercentage = TaxablePercentage
        self.TaxablePercentage_nsprefix_ = None
        if isinstance(ValidFromTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ValidFromTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ValidFromTime
        self.ValidFromTime = initvalue_
        self.ValidFromTime_nsprefix_ = None
        if isinstance(ValidToTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ValidToTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ValidToTime
        self.ValidToTime = initvalue_
        self.ValidToTime_nsprefix_ = None
        if isinstance(FromDateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FromDateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = FromDateOfBirth
        self.FromDateOfBirth = initvalue_
        self.FromDateOfBirth_nsprefix_ = None
        if isinstance(ToDateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ToDateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = ToDateOfBirth
        self.ToDateOfBirth = initvalue_
        self.ToDateOfBirth_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Fee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Fee.subclass:
            return Fee.subclass(*args_, **kwargs_)
        else:
            return Fee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def add_Name(self, value):
        self.Name.append(value)
    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)
    def replace_Name_at(self, index, value):
        self.Name[index] = value
    def get_Amount(self):
        return self.Amount
    def set_Amount(self, Amount):
        self.Amount = Amount
    def get_TaxableAmount(self):
        return self.TaxableAmount
    def set_TaxableAmount(self, TaxableAmount):
        self.TaxableAmount = TaxableAmount
    def get_Percentage(self):
        return self.Percentage
    def set_Percentage(self, Percentage):
        self.Percentage = Percentage
    def get_TaxablePercentage(self):
        return self.TaxablePercentage
    def set_TaxablePercentage(self, TaxablePercentage):
        self.TaxablePercentage = TaxablePercentage
    def get_ValidFromTime(self):
        return self.ValidFromTime
    def set_ValidFromTime(self, ValidFromTime):
        self.ValidFromTime = ValidFromTime
    def get_ValidToTime(self):
        return self.ValidToTime
    def set_ValidToTime(self, ValidToTime):
        self.ValidToTime = ValidToTime
    def get_FromDateOfBirth(self):
        return self.FromDateOfBirth
    def set_FromDateOfBirth(self, FromDateOfBirth):
        self.FromDateOfBirth = FromDateOfBirth
    def get_ToDateOfBirth(self):
        return self.ToDateOfBirth
    def set_ToDateOfBirth(self, ToDateOfBirth):
        self.ToDateOfBirth = ToDateOfBirth
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_typeType3(self, value):
        # Validate type typeType3, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Normal', 'Late']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name or
            self.Amount is not None or
            self.TaxableAmount is not None or
            self.Percentage is not None or
            self.TaxablePercentage is not None or
            self.ValidFromTime is not None or
            self.ValidToTime is not None or
            self.FromDateOfBirth is not None or
            self.ToDateOfBirth is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Fee', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Fee')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Fee':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Fee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Fee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Fee'):
        if self.type_ != "Normal" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Fee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.Amount is not None:
            namespaceprefix_ = self.Amount_nsprefix_ + ':' if (UseCapturedNS_ and self.Amount_nsprefix_) else ''
            self.Amount.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Amount', pretty_print=pretty_print)
        if self.TaxableAmount is not None:
            namespaceprefix_ = self.TaxableAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxableAmount_nsprefix_) else ''
            self.TaxableAmount.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxableAmount', pretty_print=pretty_print)
        if self.Percentage is not None:
            namespaceprefix_ = self.Percentage_nsprefix_ + ':' if (UseCapturedNS_ and self.Percentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPercentage>%s</%sPercentage>%s' % (namespaceprefix_ , self.gds_format_double(self.Percentage, input_name='Percentage'), namespaceprefix_ , eol_))
        if self.TaxablePercentage is not None:
            namespaceprefix_ = self.TaxablePercentage_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxablePercentage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTaxablePercentage>%s</%sTaxablePercentage>%s' % (namespaceprefix_ , self.gds_format_double(self.TaxablePercentage, input_name='TaxablePercentage'), namespaceprefix_ , eol_))
        if self.ValidFromTime is not None:
            namespaceprefix_ = self.ValidFromTime_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidFromTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidFromTime>%s</%sValidFromTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.ValidFromTime, input_name='ValidFromTime'), namespaceprefix_ , eol_))
        if self.ValidToTime is not None:
            namespaceprefix_ = self.ValidToTime_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidToTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidToTime>%s</%sValidToTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.ValidToTime, input_name='ValidToTime'), namespaceprefix_ , eol_))
        if self.FromDateOfBirth is not None:
            namespaceprefix_ = self.FromDateOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.FromDateOfBirth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFromDateOfBirth>%s</%sFromDateOfBirth>%s' % (namespaceprefix_ , self.gds_format_date(self.FromDateOfBirth, input_name='FromDateOfBirth'), namespaceprefix_ , eol_))
        if self.ToDateOfBirth is not None:
            namespaceprefix_ = self.ToDateOfBirth_nsprefix_ + ':' if (UseCapturedNS_ and self.ToDateOfBirth_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToDateOfBirth>%s</%sToDateOfBirth>%s' % (namespaceprefix_ , self.gds_format_date(self.ToDateOfBirth, input_name='ToDateOfBirth'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType3(self.type_)    # validate type typeType3
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            obj_ = LanguageString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Amount':
            obj_ = Amount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
        elif nodeName_ == 'TaxableAmount':
            obj_ = Amount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxableAmount = obj_
            obj_.original_tagname_ = 'TaxableAmount'
        elif nodeName_ == 'Percentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Percentage')
            fval_ = self.gds_validate_double(fval_, node, 'Percentage')
            self.Percentage = fval_
            self.Percentage_nsprefix_ = child_.prefix
        elif nodeName_ == 'TaxablePercentage' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'TaxablePercentage')
            fval_ = self.gds_validate_double(fval_, node, 'TaxablePercentage')
            self.TaxablePercentage = fval_
            self.TaxablePercentage_nsprefix_ = child_.prefix
        elif nodeName_ == 'ValidFromTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ValidFromTime = dval_
            self.ValidFromTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'ValidToTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ValidToTime = dval_
            self.ValidToTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'FromDateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.FromDateOfBirth = dval_
            self.FromDateOfBirth_nsprefix_ = child_.prefix
        elif nodeName_ == 'ToDateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ToDateOfBirth = dval_
            self.ToDateOfBirth_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Fee


class AssignedFee(GeneratedsSuper):
    """Contains information about a fee that has been assigned to a competitor
    or a team, and the amount that has been paid."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Fee=None, PaidAmount=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Fee = Fee
        self.Fee_nsprefix_ = None
        self.PaidAmount = PaidAmount
        self.PaidAmount_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssignedFee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssignedFee.subclass:
            return AssignedFee.subclass(*args_, **kwargs_)
        else:
            return AssignedFee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Fee(self):
        return self.Fee
    def set_Fee(self, Fee):
        self.Fee = Fee
    def get_PaidAmount(self):
        return self.PaidAmount
    def set_PaidAmount(self, PaidAmount):
        self.PaidAmount = PaidAmount
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Fee is not None or
            self.PaidAmount is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='AssignedFee', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssignedFee')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssignedFee':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssignedFee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssignedFee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssignedFee'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='AssignedFee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Fee is not None:
            namespaceprefix_ = self.Fee_nsprefix_ + ':' if (UseCapturedNS_ and self.Fee_nsprefix_) else ''
            self.Fee.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Fee', pretty_print=pretty_print)
        if self.PaidAmount is not None:
            namespaceprefix_ = self.PaidAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.PaidAmount_nsprefix_) else ''
            self.PaidAmount.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PaidAmount', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Fee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Fee = obj_
            obj_.original_tagname_ = 'Fee'
        elif nodeName_ == 'PaidAmount':
            obj_ = Amount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PaidAmount = obj_
            obj_.original_tagname_ = 'PaidAmount'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class AssignedFee


class Amount(GeneratedsSuper):
    """Defines a monetary amount."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currency=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currency = _cast(None, currency)
        self.currency_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Amount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Amount.subclass:
            return Amount.subclass(*args_, **kwargs_)
        else:
            return Amount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Amount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Amount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Amount':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Amount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Amount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Amount'):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Amount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Amount


class PersonEntry(GeneratedsSuper):
    """Defines an event entry for a person."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Id=None, Person=None, Organisation=None, ControlCard=None, Score=None, Class=None, RaceNumber=None, AssignedFee=None, ServiceRequest=None, StartTimeAllocationRequest=None, EntryTime=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if RaceNumber is None:
            self.RaceNumber = []
        else:
            self.RaceNumber = RaceNumber
        self.RaceNumber_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.StartTimeAllocationRequest = StartTimeAllocationRequest
        self.StartTimeAllocationRequest_nsprefix_ = None
        if isinstance(EntryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EntryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EntryTime
        self.EntryTime = initvalue_
        self.EntryTime_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonEntry.subclass:
            return PersonEntry.subclass(*args_, **kwargs_)
        else:
            return PersonEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def add_Class(self, value):
        self.Class.append(value)
    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)
    def replace_Class_at(self, index, value):
        self.Class[index] = value
    def get_RaceNumber(self):
        return self.RaceNumber
    def set_RaceNumber(self, RaceNumber):
        self.RaceNumber = RaceNumber
    def add_RaceNumber(self, value):
        self.RaceNumber.append(value)
    def insert_RaceNumber_at(self, index, value):
        self.RaceNumber.insert(index, value)
    def replace_RaceNumber_at(self, index, value):
        self.RaceNumber[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_StartTimeAllocationRequest(self):
        return self.StartTimeAllocationRequest
    def set_StartTimeAllocationRequest(self, StartTimeAllocationRequest):
        self.StartTimeAllocationRequest = StartTimeAllocationRequest
    def get_EntryTime(self):
        return self.EntryTime
    def set_EntryTime(self, EntryTime):
        self.EntryTime = EntryTime
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Person is not None or
            self.Organisation is not None or
            self.ControlCard or
            self.Score or
            self.Class or
            self.RaceNumber or
            self.AssignedFee or
            self.ServiceRequest or
            self.StartTimeAllocationRequest is not None or
            self.EntryTime is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonEntry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonEntry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonEntry'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        for Class_ in self.Class:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            Class_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for RaceNumber_ in self.RaceNumber:
            namespaceprefix_ = self.RaceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.RaceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRaceNumber>%s</%sRaceNumber>%s' % (namespaceprefix_ , self.gds_format_integer(RaceNumber_, input_name='RaceNumber'), namespaceprefix_ , eol_))
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.StartTimeAllocationRequest is not None:
            namespaceprefix_ = self.StartTimeAllocationRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTimeAllocationRequest_nsprefix_) else ''
            self.StartTimeAllocationRequest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartTimeAllocationRequest', pretty_print=pretty_print)
        if self.EntryTime is not None:
            namespaceprefix_ = self.EntryTime_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEntryTime>%s</%sEntryTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.EntryTime, input_name='EntryTime'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class.append(obj_)
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'RaceNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RaceNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'RaceNumber')
            self.RaceNumber.append(ival_)
            self.RaceNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'StartTimeAllocationRequest':
            obj_ = StartTimeAllocationRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartTimeAllocationRequest = obj_
            obj_.original_tagname_ = 'StartTimeAllocationRequest'
        elif nodeName_ == 'EntryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EntryTime = dval_
            self.EntryTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonEntry


class TeamEntry(GeneratedsSuper):
    """Defines an event entry for a team."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Id=None, Name=None, Organisation=None, TeamEntryPerson=None, Class=None, Race=None, AssignedFee=None, ServiceRequest=None, StartTimeAllocationRequest=None, ContactInformation=None, EntryTime=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if TeamEntryPerson is None:
            self.TeamEntryPerson = []
        else:
            self.TeamEntryPerson = TeamEntryPerson
        self.TeamEntryPerson_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if Race is None:
            self.Race = []
        else:
            self.Race = Race
        self.Race_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.StartTimeAllocationRequest = StartTimeAllocationRequest
        self.StartTimeAllocationRequest_nsprefix_ = None
        self.ContactInformation = ContactInformation
        self.ContactInformation_nsprefix_ = None
        if isinstance(EntryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EntryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EntryTime
        self.EntryTime = initvalue_
        self.EntryTime_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamEntry.subclass:
            return TeamEntry.subclass(*args_, **kwargs_)
        else:
            return TeamEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def add_Organisation(self, value):
        self.Organisation.append(value)
    def insert_Organisation_at(self, index, value):
        self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value):
        self.Organisation[index] = value
    def get_TeamEntryPerson(self):
        return self.TeamEntryPerson
    def set_TeamEntryPerson(self, TeamEntryPerson):
        self.TeamEntryPerson = TeamEntryPerson
    def add_TeamEntryPerson(self, value):
        self.TeamEntryPerson.append(value)
    def insert_TeamEntryPerson_at(self, index, value):
        self.TeamEntryPerson.insert(index, value)
    def replace_TeamEntryPerson_at(self, index, value):
        self.TeamEntryPerson[index] = value
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def add_Class(self, value):
        self.Class.append(value)
    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)
    def replace_Class_at(self, index, value):
        self.Class[index] = value
    def get_Race(self):
        return self.Race
    def set_Race(self, Race):
        self.Race = Race
    def add_Race(self, value):
        self.Race.append(value)
    def insert_Race_at(self, index, value):
        self.Race.insert(index, value)
    def replace_Race_at(self, index, value):
        self.Race[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_StartTimeAllocationRequest(self):
        return self.StartTimeAllocationRequest
    def set_StartTimeAllocationRequest(self, StartTimeAllocationRequest):
        self.StartTimeAllocationRequest = StartTimeAllocationRequest
    def get_ContactInformation(self):
        return self.ContactInformation
    def set_ContactInformation(self, ContactInformation):
        self.ContactInformation = ContactInformation
    def get_EntryTime(self):
        return self.EntryTime
    def set_EntryTime(self, EntryTime):
        self.EntryTime = EntryTime
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.Organisation or
            self.TeamEntryPerson or
            self.Class or
            self.Race or
            self.AssignedFee or
            self.ServiceRequest or
            self.StartTimeAllocationRequest is not None or
            self.ContactInformation is not None or
            self.EntryTime is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamEntry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamEntry':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamEntry'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        for Organisation_ in self.Organisation:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            Organisation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for TeamEntryPerson_ in self.TeamEntryPerson:
            namespaceprefix_ = self.TeamEntryPerson_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamEntryPerson_nsprefix_) else ''
            TeamEntryPerson_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamEntryPerson', pretty_print=pretty_print)
        for Class_ in self.Class:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            Class_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for Race_ in self.Race:
            namespaceprefix_ = self.Race_nsprefix_ + ':' if (UseCapturedNS_ and self.Race_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRace>%s</%sRace>%s' % (namespaceprefix_ , self.gds_format_integer(Race_, input_name='Race'), namespaceprefix_ , eol_))
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.StartTimeAllocationRequest is not None:
            namespaceprefix_ = self.StartTimeAllocationRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTimeAllocationRequest_nsprefix_) else ''
            self.StartTimeAllocationRequest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartTimeAllocationRequest', pretty_print=pretty_print)
        if self.ContactInformation is not None:
            namespaceprefix_ = self.ContactInformation_nsprefix_ + ':' if (UseCapturedNS_ and self.ContactInformation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContactInformation>%s</%sContactInformation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ContactInformation), input_name='ContactInformation')), namespaceprefix_ , eol_))
        if self.EntryTime is not None:
            namespaceprefix_ = self.EntryTime_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEntryTime>%s</%sEntryTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.EntryTime, input_name='EntryTime'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'TeamEntryPerson':
            obj_ = TeamEntryPerson.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamEntryPerson.append(obj_)
            obj_.original_tagname_ = 'TeamEntryPerson'
        elif nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class.append(obj_)
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Race' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Race')
            ival_ = self.gds_validate_integer(ival_, node, 'Race')
            self.Race.append(ival_)
            self.Race_nsprefix_ = child_.prefix
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'StartTimeAllocationRequest':
            obj_ = StartTimeAllocationRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartTimeAllocationRequest = obj_
            obj_.original_tagname_ = 'StartTimeAllocationRequest'
        elif nodeName_ == 'ContactInformation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ContactInformation')
            value_ = self.gds_validate_string(value_, node, 'ContactInformation')
            self.ContactInformation = value_
            self.ContactInformation_nsprefix_ = child_.prefix
        elif nodeName_ == 'EntryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EntryTime = dval_
            self.EntryTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamEntry


class TeamEntryPerson(GeneratedsSuper):
    """Defines a person that is part of a team entry."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Person=None, Organisation=None, Leg=None, LegOrder=None, ControlCard=None, Score=None, AssignedFee=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        self.Leg = Leg
        self.Leg_nsprefix_ = None
        self.LegOrder = LegOrder
        self.LegOrder_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamEntryPerson)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamEntryPerson.subclass:
            return TeamEntryPerson.subclass(*args_, **kwargs_)
        else:
            return TeamEntryPerson(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Leg(self):
        return self.Leg
    def set_Leg(self, Leg):
        self.Leg = Leg
    def get_LegOrder(self):
        return self.LegOrder
    def set_LegOrder(self, LegOrder):
        self.LegOrder = LegOrder
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Person is not None or
            self.Organisation is not None or
            self.Leg is not None or
            self.LegOrder is not None or
            self.ControlCard or
            self.Score or
            self.AssignedFee or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamEntryPerson', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamEntryPerson')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamEntryPerson':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamEntryPerson')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamEntryPerson', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamEntryPerson'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamEntryPerson', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        if self.Leg is not None:
            namespaceprefix_ = self.Leg_nsprefix_ + ':' if (UseCapturedNS_ and self.Leg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLeg>%s</%sLeg>%s' % (namespaceprefix_ , self.gds_format_integer(self.Leg, input_name='Leg'), namespaceprefix_ , eol_))
        if self.LegOrder is not None:
            namespaceprefix_ = self.LegOrder_nsprefix_ + ':' if (UseCapturedNS_ and self.LegOrder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLegOrder>%s</%sLegOrder>%s' % (namespaceprefix_ , self.gds_format_integer(self.LegOrder, input_name='LegOrder'), namespaceprefix_ , eol_))
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Leg' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Leg')
            ival_ = self.gds_validate_integer(ival_, node, 'Leg')
            self.Leg = ival_
            self.Leg_nsprefix_ = child_.prefix
        elif nodeName_ == 'LegOrder' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LegOrder')
            ival_ = self.gds_validate_integer(ival_, node, 'LegOrder')
            self.LegOrder = ival_
            self.LegOrder_nsprefix_ = child_.prefix
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamEntryPerson


class StartTimeAllocationRequest(GeneratedsSuper):
    """Used to state start time allocation requests. It consists of a possible
    reference Organisation or Person and the allocation request, e.g. late
    start or grouped with the reference Organisation/Person. This way it is
    possible to state requests to the event organizer so that e.g. all
    members of an organisation has start times close to each other - or
    parents have start times far from each other. It is totally up to the
    event software and organizers whether they will support such requests.
    The type of start time allocation request."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='Normal', Organisation=None, Person=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StartTimeAllocationRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StartTimeAllocationRequest.subclass:
            return StartTimeAllocationRequest.subclass(*args_, **kwargs_)
        else:
            return StartTimeAllocationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_typeType4(self, value):
        # Validate type typeType4, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Normal', 'EarlyStart', 'LateStart', 'SeparatedFrom', 'GroupedWith']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Organisation is not None or
            self.Person is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='StartTimeAllocationRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StartTimeAllocationRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StartTimeAllocationRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StartTimeAllocationRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StartTimeAllocationRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StartTimeAllocationRequest'):
        if self.type_ != "Normal" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='StartTimeAllocationRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType4(self.type_)    # validate type typeType4
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
# end class StartTimeAllocationRequest


class ClassStart(GeneratedsSuper):
    """The start list of a single class containing either individual start
    times or team start times.
    The time resolution of the start times, normally 1. For tenths of a second,
    use 0.1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, timeResolution=1, modifyTime=None, Class=None, Course=None, StartName=None, PersonStart=None, TeamStart=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.timeResolution = _cast(float, timeResolution)
        self.timeResolution_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Class = Class
        self.Class_nsprefix_ = None
        if Course is None:
            self.Course = []
        else:
            self.Course = Course
        self.Course_nsprefix_ = None
        if StartName is None:
            self.StartName = []
        else:
            self.StartName = StartName
        self.StartName_nsprefix_ = None
        if PersonStart is None:
            self.PersonStart = []
        else:
            self.PersonStart = PersonStart
        self.PersonStart_nsprefix_ = None
        if TeamStart is None:
            self.TeamStart = []
        else:
            self.TeamStart = TeamStart
        self.TeamStart_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassStart.subclass:
            return ClassStart.subclass(*args_, **kwargs_)
        else:
            return ClassStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def add_Course(self, value):
        self.Course.append(value)
    def insert_Course_at(self, index, value):
        self.Course.insert(index, value)
    def replace_Course_at(self, index, value):
        self.Course[index] = value
    def get_StartName(self):
        return self.StartName
    def set_StartName(self, StartName):
        self.StartName = StartName
    def add_StartName(self, value):
        self.StartName.append(value)
    def insert_StartName_at(self, index, value):
        self.StartName.insert(index, value)
    def replace_StartName_at(self, index, value):
        self.StartName[index] = value
    def get_PersonStart(self):
        return self.PersonStart
    def set_PersonStart(self, PersonStart):
        self.PersonStart = PersonStart
    def add_PersonStart(self, value):
        self.PersonStart.append(value)
    def insert_PersonStart_at(self, index, value):
        self.PersonStart.insert(index, value)
    def replace_PersonStart_at(self, index, value):
        self.PersonStart[index] = value
    def get_TeamStart(self):
        return self.TeamStart
    def set_TeamStart(self, TeamStart):
        self.TeamStart = TeamStart
    def add_TeamStart(self, value):
        self.TeamStart.append(value)
    def insert_TeamStart_at(self, index, value):
        self.TeamStart.insert(index, value)
    def replace_TeamStart_at(self, index, value):
        self.TeamStart[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_timeResolution(self):
        return self.timeResolution
    def set_timeResolution(self, timeResolution):
        self.timeResolution = timeResolution
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Class is not None or
            self.Course or
            self.StartName or
            self.PersonStart or
            self.TeamStart or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassStart'):
        if self.timeResolution != 1 and 'timeResolution' not in already_processed:
            already_processed.add('timeResolution')
            outfile.write(' timeResolution="%s"' % self.gds_format_double(self.timeResolution, input_name='timeResolution'))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Class is not None:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            self.Class.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for Course_ in self.Course:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            Course_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for StartName_ in self.StartName:
            namespaceprefix_ = self.StartName_nsprefix_ + ':' if (UseCapturedNS_ and self.StartName_nsprefix_) else ''
            StartName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StartName', pretty_print=pretty_print)
        for PersonStart_ in self.PersonStart:
            namespaceprefix_ = self.PersonStart_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonStart_nsprefix_) else ''
            PersonStart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonStart', pretty_print=pretty_print)
        for TeamStart_ in self.TeamStart:
            namespaceprefix_ = self.TeamStart_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamStart_nsprefix_) else ''
            TeamStart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamStart', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeResolution', node)
        if value is not None and 'timeResolution' not in already_processed:
            already_processed.add('timeResolution')
            value = self.gds_parse_double(value, node, 'timeResolution')
            self.timeResolution = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class = obj_
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Course':
            obj_ = SimpleRaceCourse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course.append(obj_)
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'StartName':
            obj_ = StartName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StartName.append(obj_)
            obj_.original_tagname_ = 'StartName'
        elif nodeName_ == 'PersonStart':
            obj_ = PersonStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonStart.append(obj_)
            obj_.original_tagname_ = 'PersonStart'
        elif nodeName_ == 'TeamStart':
            obj_ = TeamStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamStart.append(obj_)
            obj_.original_tagname_ = 'TeamStart'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class ClassStart


class StartName(GeneratedsSuper):
    """Defines the name of the start place (e.g. Start 1), if the race has
    multiple start places.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StartName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StartName.subclass:
            return StartName.subclass(*args_, **kwargs_)
        else:
            return StartName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StartName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StartName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StartName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StartName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StartName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StartName'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StartName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StartName


class PersonStart(GeneratedsSuper):
    """Start information for an individual competitor, including e.g. start
    time and bib number."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, EntryId=None, Person=None, Organisation=None, Start=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if Start is None:
            self.Start = []
        else:
            self.Start = Start
        self.Start_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonStart.subclass:
            return PersonStart.subclass(*args_, **kwargs_)
        else:
            return PersonStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Start(self):
        return self.Start
    def set_Start(self, Start):
        self.Start = Start
    def add_Start(self, value):
        self.Start.append(value)
    def insert_Start_at(self, index, value):
        self.Start.insert(index, value)
    def replace_Start_at(self, index, value):
        self.Start[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Person is not None or
            self.Organisation is not None or
            self.Start or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonStart'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for Start_ in self.Start:
            namespaceprefix_ = self.Start_nsprefix_ + ':' if (UseCapturedNS_ and self.Start_nsprefix_) else ''
            Start_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Start', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Start':
            obj_ = PersonRaceStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Start.append(obj_)
            obj_.original_tagname_ = 'Start'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonStart


class PersonRaceStart(GeneratedsSuper):
    """Start information for a person in a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, BibNumber=None, StartTime=None, Course=None, ControlCard=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.StartTime_nsprefix_ = None
        self.Course = Course
        self.Course_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonRaceStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonRaceStart.subclass:
            return PersonRaceStart.subclass(*args_, **kwargs_)
        else:
            return PersonRaceStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def hasContent_(self):
        if (
            self.BibNumber is not None or
            self.StartTime is not None or
            self.Course is not None or
            self.ControlCard or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonRaceStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonRaceStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonRaceStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonRaceStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonRaceStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonRaceStart'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonRaceStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespaceprefix_ , eol_))
        if self.Course is not None:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            self.Course.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
            self.StartTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Course':
            class_obj_ = self.get_class_obj_(child_, SimpleCourse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course = obj_
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonRaceStart


class TeamStart(GeneratedsSuper):
    """Start information for a team, including e.g. team name, start times and
    bib numbers."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, EntryId=None, Name=None, Organisation=None, BibNumber=None, TeamMemberStart=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if TeamMemberStart is None:
            self.TeamMemberStart = []
        else:
            self.TeamMemberStart = TeamMemberStart
        self.TeamMemberStart_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamStart.subclass:
            return TeamStart.subclass(*args_, **kwargs_)
        else:
            return TeamStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def add_Organisation(self, value):
        self.Organisation.append(value)
    def insert_Organisation_at(self, index, value):
        self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value):
        self.Organisation[index] = value
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_TeamMemberStart(self):
        return self.TeamMemberStart
    def set_TeamMemberStart(self, TeamMemberStart):
        self.TeamMemberStart = TeamMemberStart
    def add_TeamMemberStart(self, value):
        self.TeamMemberStart.append(value)
    def insert_TeamMemberStart_at(self, index, value):
        self.TeamMemberStart.insert(index, value)
    def replace_TeamMemberStart_at(self, index, value):
        self.TeamMemberStart[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Name is not None or
            self.Organisation or
            self.BibNumber is not None or
            self.TeamMemberStart or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamStart'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        for Organisation_ in self.Organisation:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            Organisation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        for TeamMemberStart_ in self.TeamMemberStart:
            namespaceprefix_ = self.TeamMemberStart_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamMemberStart_nsprefix_) else ''
            TeamMemberStart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamMemberStart', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamMemberStart':
            obj_ = TeamMemberStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamMemberStart.append(obj_)
            obj_.original_tagname_ = 'TeamMemberStart'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamStart


class TeamMemberStart(GeneratedsSuper):
    """Start information for an individual competitor, including e.g. start
    time and bib number."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, EntryId=None, Person=None, Organisation=None, Start=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if Start is None:
            self.Start = []
        else:
            self.Start = Start
        self.Start_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamMemberStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamMemberStart.subclass:
            return TeamMemberStart.subclass(*args_, **kwargs_)
        else:
            return TeamMemberStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Start(self):
        return self.Start
    def set_Start(self, Start):
        self.Start = Start
    def add_Start(self, value):
        self.Start.append(value)
    def insert_Start_at(self, index, value):
        self.Start.insert(index, value)
    def replace_Start_at(self, index, value):
        self.Start[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Person is not None or
            self.Organisation is not None or
            self.Start or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamMemberStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamMemberStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamMemberStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamMemberStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamMemberStart'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for Start_ in self.Start:
            namespaceprefix_ = self.Start_nsprefix_ + ':' if (UseCapturedNS_ and self.Start_nsprefix_) else ''
            Start_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Start', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Start':
            obj_ = TeamMemberRaceStart.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Start.append(obj_)
            obj_.original_tagname_ = 'Start'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamMemberStart


class TeamMemberRaceStart(GeneratedsSuper):
    """Start information for a team member in a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, Leg=None, LegOrder=None, BibNumber=None, StartTime=None, Course=None, ControlCard=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.Leg = Leg
        self.Leg_nsprefix_ = None
        self.LegOrder = LegOrder
        self.LegOrder_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.StartTime_nsprefix_ = None
        self.Course = Course
        self.Course_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamMemberRaceStart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamMemberRaceStart.subclass:
            return TeamMemberRaceStart.subclass(*args_, **kwargs_)
        else:
            return TeamMemberRaceStart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Leg(self):
        return self.Leg
    def set_Leg(self, Leg):
        self.Leg = Leg
    def get_LegOrder(self):
        return self.LegOrder
    def set_LegOrder(self, LegOrder):
        self.LegOrder = LegOrder
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def hasContent_(self):
        if (
            self.Leg is not None or
            self.LegOrder is not None or
            self.BibNumber is not None or
            self.StartTime is not None or
            self.Course is not None or
            self.ControlCard or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberRaceStart', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamMemberRaceStart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamMemberRaceStart':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamMemberRaceStart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamMemberRaceStart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamMemberRaceStart'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberRaceStart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Leg is not None:
            namespaceprefix_ = self.Leg_nsprefix_ + ':' if (UseCapturedNS_ and self.Leg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLeg>%s</%sLeg>%s' % (namespaceprefix_ , self.gds_format_integer(self.Leg, input_name='Leg'), namespaceprefix_ , eol_))
        if self.LegOrder is not None:
            namespaceprefix_ = self.LegOrder_nsprefix_ + ':' if (UseCapturedNS_ and self.LegOrder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLegOrder>%s</%sLegOrder>%s' % (namespaceprefix_ , self.gds_format_integer(self.LegOrder, input_name='LegOrder'), namespaceprefix_ , eol_))
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespaceprefix_ , eol_))
        if self.Course is not None:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            self.Course.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Leg' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Leg')
            ival_ = self.gds_validate_integer(ival_, node, 'Leg')
            self.Leg = ival_
            self.Leg_nsprefix_ = child_.prefix
        elif nodeName_ == 'LegOrder' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LegOrder')
            ival_ = self.gds_validate_integer(ival_, node, 'LegOrder')
            self.LegOrder = ival_
            self.LegOrder_nsprefix_ = child_.prefix
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
            self.StartTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Course':
            class_obj_ = self.get_class_obj_(child_, SimpleCourse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course = obj_
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamMemberRaceStart


class ClassResult(GeneratedsSuper):
    """The result list for a single class containing either individual results
    or team results.
    The time resolution of the results, normally 1. For tenths of a second, use
    0.1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, timeResolution=1, modifyTime=None, Class=None, Course=None, PersonResult=None, TeamResult=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.timeResolution = _cast(float, timeResolution)
        self.timeResolution_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Class = Class
        self.Class_nsprefix_ = None
        if Course is None:
            self.Course = []
        else:
            self.Course = Course
        self.Course_nsprefix_ = None
        if PersonResult is None:
            self.PersonResult = []
        else:
            self.PersonResult = PersonResult
        self.PersonResult_nsprefix_ = None
        if TeamResult is None:
            self.TeamResult = []
        else:
            self.TeamResult = TeamResult
        self.TeamResult_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassResult.subclass:
            return ClassResult.subclass(*args_, **kwargs_)
        else:
            return ClassResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Class(self):
        return self.Class
    def set_Class(self, Class):
        self.Class = Class
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def add_Course(self, value):
        self.Course.append(value)
    def insert_Course_at(self, index, value):
        self.Course.insert(index, value)
    def replace_Course_at(self, index, value):
        self.Course[index] = value
    def get_PersonResult(self):
        return self.PersonResult
    def set_PersonResult(self, PersonResult):
        self.PersonResult = PersonResult
    def add_PersonResult(self, value):
        self.PersonResult.append(value)
    def insert_PersonResult_at(self, index, value):
        self.PersonResult.insert(index, value)
    def replace_PersonResult_at(self, index, value):
        self.PersonResult[index] = value
    def get_TeamResult(self):
        return self.TeamResult
    def set_TeamResult(self, TeamResult):
        self.TeamResult = TeamResult
    def add_TeamResult(self, value):
        self.TeamResult.append(value)
    def insert_TeamResult_at(self, index, value):
        self.TeamResult.insert(index, value)
    def replace_TeamResult_at(self, index, value):
        self.TeamResult[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_timeResolution(self):
        return self.timeResolution
    def set_timeResolution(self, timeResolution):
        self.timeResolution = timeResolution
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Class is not None or
            self.Course or
            self.PersonResult or
            self.TeamResult or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassResult'):
        if self.timeResolution != 1 and 'timeResolution' not in already_processed:
            already_processed.add('timeResolution')
            outfile.write(' timeResolution="%s"' % self.gds_format_double(self.timeResolution, input_name='timeResolution'))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Class is not None:
            namespaceprefix_ = self.Class_nsprefix_ + ':' if (UseCapturedNS_ and self.Class_nsprefix_) else ''
            self.Class.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Class', pretty_print=pretty_print)
        for Course_ in self.Course:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            Course_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for PersonResult_ in self.PersonResult:
            namespaceprefix_ = self.PersonResult_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonResult_nsprefix_) else ''
            PersonResult_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonResult', pretty_print=pretty_print)
        for TeamResult_ in self.TeamResult:
            namespaceprefix_ = self.TeamResult_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamResult_nsprefix_) else ''
            TeamResult_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamResult', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeResolution', node)
        if value is not None and 'timeResolution' not in already_processed:
            already_processed.add('timeResolution')
            value = self.gds_parse_double(value, node, 'timeResolution')
            self.timeResolution = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Class':
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Class = obj_
            obj_.original_tagname_ = 'Class'
        elif nodeName_ == 'Course':
            obj_ = SimpleRaceCourse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course.append(obj_)
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'PersonResult':
            obj_ = PersonResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonResult.append(obj_)
            obj_.original_tagname_ = 'PersonResult'
        elif nodeName_ == 'TeamResult':
            obj_ = TeamResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamResult.append(obj_)
            obj_.original_tagname_ = 'TeamResult'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class ClassResult


class PersonResult(GeneratedsSuper):
    """Result information for an individual competitor, including e.g. result
    status, place, finish time, and split times."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, EntryId=None, Person=None, Organisation=None, Result=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if Result is None:
            self.Result = []
        else:
            self.Result = Result
        self.Result_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonResult.subclass:
            return PersonResult.subclass(*args_, **kwargs_)
        else:
            return PersonResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Result(self):
        return self.Result
    def set_Result(self, Result):
        self.Result = Result
    def add_Result(self, value):
        self.Result.append(value)
    def insert_Result_at(self, index, value):
        self.Result.insert(index, value)
    def replace_Result_at(self, index, value):
        self.Result[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Person is not None or
            self.Organisation is not None or
            self.Result or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonResult'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for Result_ in self.Result:
            namespaceprefix_ = self.Result_nsprefix_ + ':' if (UseCapturedNS_ and self.Result_nsprefix_) else ''
            Result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Result', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Result':
            obj_ = PersonRaceResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Result.append(obj_)
            obj_.original_tagname_ = 'Result'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonResult


class PersonRaceResult(GeneratedsSuper):
    """Result information for a person in a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, BibNumber=None, StartTime=None, FinishTime=None, Time=None, TimeBehind=None, Position=None, Status=None, Score=None, OverallResult=None, Course=None, SplitTime=None, ControlAnswer=None, Route=None, ControlCard=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.StartTime_nsprefix_ = None
        if isinstance(FinishTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FinishTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = FinishTime
        self.FinishTime = initvalue_
        self.FinishTime_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
        self.TimeBehind = TimeBehind
        self.TimeBehind_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        self.Status = Status
        self.validate_ResultStatus(self.Status)
        self.Status_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        self.OverallResult = OverallResult
        self.OverallResult_nsprefix_ = None
        self.Course = Course
        self.Course_nsprefix_ = None
        if SplitTime is None:
            self.SplitTime = []
        else:
            self.SplitTime = SplitTime
        self.SplitTime_nsprefix_ = None
        if ControlAnswer is None:
            self.ControlAnswer = []
        else:
            self.ControlAnswer = ControlAnswer
        self.ControlAnswer_nsprefix_ = None
        self.Route = Route
        self.Route_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonRaceResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonRaceResult.subclass:
            return PersonRaceResult.subclass(*args_, **kwargs_)
        else:
            return PersonRaceResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_FinishTime(self):
        return self.FinishTime
    def set_FinishTime(self, FinishTime):
        self.FinishTime = FinishTime
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_TimeBehind(self):
        return self.TimeBehind
    def set_TimeBehind(self, TimeBehind):
        self.TimeBehind = TimeBehind
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_OverallResult(self):
        return self.OverallResult
    def set_OverallResult(self, OverallResult):
        self.OverallResult = OverallResult
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def get_SplitTime(self):
        return self.SplitTime
    def set_SplitTime(self, SplitTime):
        self.SplitTime = SplitTime
    def add_SplitTime(self, value):
        self.SplitTime.append(value)
    def insert_SplitTime_at(self, index, value):
        self.SplitTime.insert(index, value)
    def replace_SplitTime_at(self, index, value):
        self.SplitTime[index] = value
    def get_ControlAnswer(self):
        return self.ControlAnswer
    def set_ControlAnswer(self, ControlAnswer):
        self.ControlAnswer = ControlAnswer
    def add_ControlAnswer(self, value):
        self.ControlAnswer.append(value)
    def insert_ControlAnswer_at(self, index, value):
        self.ControlAnswer.insert(index, value)
    def replace_ControlAnswer_at(self, index, value):
        self.ControlAnswer[index] = value
    def get_Route(self):
        return self.Route
    def set_Route(self, Route):
        self.Route = Route
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def validate_ResultStatus(self, value):
        result = True
        # Validate type ResultStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'Finished', 'MissingPunch', 'Disqualified', 'DidNotFinish', 'Active', 'Inactive', 'OverTime', 'SportingWithdrawal', 'NotCompeting', 'Moved', 'MovedUp', 'DidNotStart', 'DidNotEnter', 'Cancelled']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ResultStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.BibNumber is not None or
            self.StartTime is not None or
            self.FinishTime is not None or
            self.Time is not None or
            self.TimeBehind is not None or
            self.Position is not None or
            self.Status is not None or
            self.Score or
            self.OverallResult is not None or
            self.Course is not None or
            self.SplitTime or
            self.ControlAnswer or
            self.Route is not None or
            self.ControlCard or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonRaceResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonRaceResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonRaceResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonRaceResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonRaceResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonRaceResult'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonRaceResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespaceprefix_ , eol_))
        if self.FinishTime is not None:
            namespaceprefix_ = self.FinishTime_nsprefix_ + ':' if (UseCapturedNS_ and self.FinishTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinishTime>%s</%sFinishTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.FinishTime, input_name='FinishTime'), namespaceprefix_ , eol_))
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_double(self.Time, input_name='Time'), namespaceprefix_ , eol_))
        if self.TimeBehind is not None:
            namespaceprefix_ = self.TimeBehind_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeBehind_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeBehind>%s</%sTimeBehind>%s' % (namespaceprefix_ , self.gds_format_double(self.TimeBehind, input_name='TimeBehind'), namespaceprefix_ , eol_))
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition>%s</%sPosition>%s' % (namespaceprefix_ , self.gds_format_integer(self.Position, input_name='Position'), namespaceprefix_ , eol_))
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        if self.OverallResult is not None:
            namespaceprefix_ = self.OverallResult_nsprefix_ + ':' if (UseCapturedNS_ and self.OverallResult_nsprefix_) else ''
            self.OverallResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OverallResult', pretty_print=pretty_print)
        if self.Course is not None:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            self.Course.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for SplitTime_ in self.SplitTime:
            namespaceprefix_ = self.SplitTime_nsprefix_ + ':' if (UseCapturedNS_ and self.SplitTime_nsprefix_) else ''
            SplitTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplitTime', pretty_print=pretty_print)
        for ControlAnswer_ in self.ControlAnswer:
            namespaceprefix_ = self.ControlAnswer_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlAnswer_nsprefix_) else ''
            ControlAnswer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlAnswer', pretty_print=pretty_print)
        if self.Route is not None:
            namespaceprefix_ = self.Route_nsprefix_ + ':' if (UseCapturedNS_ and self.Route_nsprefix_) else ''
            self.Route.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Route', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
            self.StartTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'FinishTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.FinishTime = dval_
            self.FinishTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Time' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Time')
            fval_ = self.gds_validate_double(fval_, node, 'Time')
            self.Time = fval_
            self.Time_nsprefix_ = child_.prefix
        elif nodeName_ == 'TimeBehind' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'TimeBehind')
            fval_ = self.gds_validate_double(fval_, node, 'TimeBehind')
            self.TimeBehind = fval_
            self.TimeBehind_nsprefix_ = child_.prefix
        elif nodeName_ == 'Position' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Position')
            ival_ = self.gds_validate_integer(ival_, node, 'Position')
            self.Position = ival_
            self.Position_nsprefix_ = child_.prefix
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type ResultStatus
            self.validate_ResultStatus(self.Status)
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'OverallResult':
            obj_ = OverallResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OverallResult = obj_
            obj_.original_tagname_ = 'OverallResult'
        elif nodeName_ == 'Course':
            class_obj_ = self.get_class_obj_(child_, SimpleCourse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course = obj_
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'SplitTime':
            obj_ = SplitTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplitTime.append(obj_)
            obj_.original_tagname_ = 'SplitTime'
        elif nodeName_ == 'ControlAnswer':
            obj_ = ControlAnswer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlAnswer.append(obj_)
            obj_.original_tagname_ = 'ControlAnswer'
        elif nodeName_ == 'Route':
            obj_ = Route.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Route = obj_
            obj_.original_tagname_ = 'Route'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonRaceResult


class TeamResult(GeneratedsSuper):
    """Result information for a team, including e.g. result status, place,
    finish time and individual times for the team members."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EntryId=None, Name=None, Organisation=None, BibNumber=None, TeamMemberResult=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if TeamMemberResult is None:
            self.TeamMemberResult = []
        else:
            self.TeamMemberResult = TeamMemberResult
        self.TeamMemberResult_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamResult.subclass:
            return TeamResult.subclass(*args_, **kwargs_)
        else:
            return TeamResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def add_Organisation(self, value):
        self.Organisation.append(value)
    def insert_Organisation_at(self, index, value):
        self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value):
        self.Organisation[index] = value
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_TeamMemberResult(self):
        return self.TeamMemberResult
    def set_TeamMemberResult(self, TeamMemberResult):
        self.TeamMemberResult = TeamMemberResult
    def add_TeamMemberResult(self, value):
        self.TeamMemberResult.append(value)
    def insert_TeamMemberResult_at(self, index, value):
        self.TeamMemberResult.insert(index, value)
    def replace_TeamMemberResult_at(self, index, value):
        self.TeamMemberResult[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Name is not None or
            self.Organisation or
            self.BibNumber is not None or
            self.TeamMemberResult or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        for Organisation_ in self.Organisation:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            Organisation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        for TeamMemberResult_ in self.TeamMemberResult:
            namespaceprefix_ = self.TeamMemberResult_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamMemberResult_nsprefix_) else ''
            TeamMemberResult_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamMemberResult', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamMemberResult':
            obj_ = TeamMemberResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamMemberResult.append(obj_)
            obj_.original_tagname_ = 'TeamMemberResult'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamResult


class TeamMemberResult(GeneratedsSuper):
    """Result information for a team member, including e.g. result status,
    place, finish time, and split times."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, EntryId=None, Person=None, Organisation=None, Result=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if Result is None:
            self.Result = []
        else:
            self.Result = Result
        self.Result_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamMemberResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamMemberResult.subclass:
            return TeamMemberResult.subclass(*args_, **kwargs_)
        else:
            return TeamMemberResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_Result(self):
        return self.Result
    def set_Result(self, Result):
        self.Result = Result
    def add_Result(self, value):
        self.Result.append(value)
    def insert_Result_at(self, index, value):
        self.Result.insert(index, value)
    def replace_Result_at(self, index, value):
        self.Result[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.Person is not None or
            self.Organisation is not None or
            self.Result or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamMemberResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamMemberResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamMemberResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamMemberResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamMemberResult'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for Result_ in self.Result:
            namespaceprefix_ = self.Result_nsprefix_ + ':' if (UseCapturedNS_ and self.Result_nsprefix_) else ''
            Result_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Result', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'Result':
            obj_ = TeamMemberRaceResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Result.append(obj_)
            obj_.original_tagname_ = 'Result'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamMemberResult


class TeamMemberRaceResult(GeneratedsSuper):
    """Result information for a person in a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, Leg=None, LegOrder=None, BibNumber=None, StartTime=None, FinishTime=None, Time=None, TimeBehind=None, Position=None, Status=None, Score=None, OverallResult=None, Course=None, SplitTime=None, ControlAnswer=None, Route=None, ControlCard=None, AssignedFee=None, ServiceRequest=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        self.Leg = Leg
        self.Leg_nsprefix_ = None
        self.LegOrder = LegOrder
        self.LegOrder_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        if isinstance(StartTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.StartTime_nsprefix_ = None
        if isinstance(FinishTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(FinishTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = FinishTime
        self.FinishTime = initvalue_
        self.FinishTime_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
        if TimeBehind is None:
            self.TimeBehind = []
        else:
            self.TimeBehind = TimeBehind
        self.TimeBehind_nsprefix_ = None
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        self.Position_nsprefix_ = None
        self.Status = Status
        self.validate_ResultStatus(self.Status)
        self.Status_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        self.OverallResult = OverallResult
        self.OverallResult_nsprefix_ = None
        self.Course = Course
        self.Course_nsprefix_ = None
        if SplitTime is None:
            self.SplitTime = []
        else:
            self.SplitTime = SplitTime
        self.SplitTime_nsprefix_ = None
        if ControlAnswer is None:
            self.ControlAnswer = []
        else:
            self.ControlAnswer = ControlAnswer
        self.ControlAnswer_nsprefix_ = None
        self.Route = Route
        self.Route_nsprefix_ = None
        if ControlCard is None:
            self.ControlCard = []
        else:
            self.ControlCard = ControlCard
        self.ControlCard_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamMemberRaceResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamMemberRaceResult.subclass:
            return TeamMemberRaceResult.subclass(*args_, **kwargs_)
        else:
            return TeamMemberRaceResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Leg(self):
        return self.Leg
    def set_Leg(self, Leg):
        self.Leg = Leg
    def get_LegOrder(self):
        return self.LegOrder
    def set_LegOrder(self, LegOrder):
        self.LegOrder = LegOrder
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_StartTime(self):
        return self.StartTime
    def set_StartTime(self, StartTime):
        self.StartTime = StartTime
    def get_FinishTime(self):
        return self.FinishTime
    def set_FinishTime(self, FinishTime):
        self.FinishTime = FinishTime
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_TimeBehind(self):
        return self.TimeBehind
    def set_TimeBehind(self, TimeBehind):
        self.TimeBehind = TimeBehind
    def add_TimeBehind(self, value):
        self.TimeBehind.append(value)
    def insert_TimeBehind_at(self, index, value):
        self.TimeBehind.insert(index, value)
    def replace_TimeBehind_at(self, index, value):
        self.TimeBehind[index] = value
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def add_Position(self, value):
        self.Position.append(value)
    def insert_Position_at(self, index, value):
        self.Position.insert(index, value)
    def replace_Position_at(self, index, value):
        self.Position[index] = value
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_OverallResult(self):
        return self.OverallResult
    def set_OverallResult(self, OverallResult):
        self.OverallResult = OverallResult
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def get_SplitTime(self):
        return self.SplitTime
    def set_SplitTime(self, SplitTime):
        self.SplitTime = SplitTime
    def add_SplitTime(self, value):
        self.SplitTime.append(value)
    def insert_SplitTime_at(self, index, value):
        self.SplitTime.insert(index, value)
    def replace_SplitTime_at(self, index, value):
        self.SplitTime[index] = value
    def get_ControlAnswer(self):
        return self.ControlAnswer
    def set_ControlAnswer(self, ControlAnswer):
        self.ControlAnswer = ControlAnswer
    def add_ControlAnswer(self, value):
        self.ControlAnswer.append(value)
    def insert_ControlAnswer_at(self, index, value):
        self.ControlAnswer.insert(index, value)
    def replace_ControlAnswer_at(self, index, value):
        self.ControlAnswer[index] = value
    def get_Route(self):
        return self.Route
    def set_Route(self, Route):
        self.Route = Route
    def get_ControlCard(self):
        return self.ControlCard
    def set_ControlCard(self, ControlCard):
        self.ControlCard = ControlCard
    def add_ControlCard(self, value):
        self.ControlCard.append(value)
    def insert_ControlCard_at(self, index, value):
        self.ControlCard.insert(index, value)
    def replace_ControlCard_at(self, index, value):
        self.ControlCard[index] = value
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def validate_ResultStatus(self, value):
        result = True
        # Validate type ResultStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'Finished', 'MissingPunch', 'Disqualified', 'DidNotFinish', 'Active', 'Inactive', 'OverTime', 'SportingWithdrawal', 'NotCompeting', 'Moved', 'MovedUp', 'DidNotStart', 'DidNotEnter', 'Cancelled']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ResultStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Leg is not None or
            self.LegOrder is not None or
            self.BibNumber is not None or
            self.StartTime is not None or
            self.FinishTime is not None or
            self.Time is not None or
            self.TimeBehind or
            self.Position or
            self.Status is not None or
            self.Score or
            self.OverallResult is not None or
            self.Course is not None or
            self.SplitTime or
            self.ControlAnswer or
            self.Route is not None or
            self.ControlCard or
            self.AssignedFee or
            self.ServiceRequest or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberRaceResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamMemberRaceResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamMemberRaceResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamMemberRaceResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamMemberRaceResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamMemberRaceResult'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberRaceResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Leg is not None:
            namespaceprefix_ = self.Leg_nsprefix_ + ':' if (UseCapturedNS_ and self.Leg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLeg>%s</%sLeg>%s' % (namespaceprefix_ , self.gds_format_integer(self.Leg, input_name='Leg'), namespaceprefix_ , eol_))
        if self.LegOrder is not None:
            namespaceprefix_ = self.LegOrder_nsprefix_ + ':' if (UseCapturedNS_ and self.LegOrder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLegOrder>%s</%sLegOrder>%s' % (namespaceprefix_ , self.gds_format_integer(self.LegOrder, input_name='LegOrder'), namespaceprefix_ , eol_))
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.StartTime is not None:
            namespaceprefix_ = self.StartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.StartTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespaceprefix_ , eol_))
        if self.FinishTime is not None:
            namespaceprefix_ = self.FinishTime_nsprefix_ + ':' if (UseCapturedNS_ and self.FinishTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFinishTime>%s</%sFinishTime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.FinishTime, input_name='FinishTime'), namespaceprefix_ , eol_))
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_double(self.Time, input_name='Time'), namespaceprefix_ , eol_))
        for TimeBehind_ in self.TimeBehind:
            namespaceprefix_ = self.TimeBehind_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeBehind_nsprefix_) else ''
            TimeBehind_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeBehind', pretty_print=pretty_print)
        for Position_ in self.Position:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            Position_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        if self.OverallResult is not None:
            namespaceprefix_ = self.OverallResult_nsprefix_ + ':' if (UseCapturedNS_ and self.OverallResult_nsprefix_) else ''
            self.OverallResult.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OverallResult', pretty_print=pretty_print)
        if self.Course is not None:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            self.Course.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for SplitTime_ in self.SplitTime:
            namespaceprefix_ = self.SplitTime_nsprefix_ + ':' if (UseCapturedNS_ and self.SplitTime_nsprefix_) else ''
            SplitTime_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplitTime', pretty_print=pretty_print)
        for ControlAnswer_ in self.ControlAnswer:
            namespaceprefix_ = self.ControlAnswer_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlAnswer_nsprefix_) else ''
            ControlAnswer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlAnswer', pretty_print=pretty_print)
        if self.Route is not None:
            namespaceprefix_ = self.Route_nsprefix_ + ':' if (UseCapturedNS_ and self.Route_nsprefix_) else ''
            self.Route.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Route', pretty_print=pretty_print)
        for ControlCard_ in self.ControlCard:
            namespaceprefix_ = self.ControlCard_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCard_nsprefix_) else ''
            ControlCard_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ControlCard', pretty_print=pretty_print)
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Leg' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Leg')
            ival_ = self.gds_validate_integer(ival_, node, 'Leg')
            self.Leg = ival_
            self.Leg_nsprefix_ = child_.prefix
        elif nodeName_ == 'LegOrder' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LegOrder')
            ival_ = self.gds_validate_integer(ival_, node, 'LegOrder')
            self.LegOrder = ival_
            self.LegOrder_nsprefix_ = child_.prefix
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
            self.StartTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'FinishTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.FinishTime = dval_
            self.FinishTime_nsprefix_ = child_.prefix
        elif nodeName_ == 'Time' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Time')
            fval_ = self.gds_validate_double(fval_, node, 'Time')
            self.Time = fval_
            self.Time_nsprefix_ = child_.prefix
        elif nodeName_ == 'TimeBehind':
            obj_ = TimeBehindType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeBehind.append(obj_)
            obj_.original_tagname_ = 'TimeBehind'
        elif nodeName_ == 'Position':
            obj_ = PositionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position.append(obj_)
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type ResultStatus
            self.validate_ResultStatus(self.Status)
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'OverallResult':
            obj_ = OverallResult.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OverallResult = obj_
            obj_.original_tagname_ = 'OverallResult'
        elif nodeName_ == 'Course':
            class_obj_ = self.get_class_obj_(child_, SimpleCourse)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course = obj_
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'SplitTime':
            obj_ = SplitTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplitTime.append(obj_)
            obj_.original_tagname_ = 'SplitTime'
        elif nodeName_ == 'ControlAnswer':
            obj_ = ControlAnswer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlAnswer.append(obj_)
            obj_.original_tagname_ = 'ControlAnswer'
        elif nodeName_ == 'Route':
            obj_ = Route.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Route = obj_
            obj_.original_tagname_ = 'Route'
        elif nodeName_ == 'ControlCard':
            obj_ = ControlCard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ControlCard.append(obj_)
            obj_.original_tagname_ = 'ControlCard'
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamMemberRaceResult


class OverallResult(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Time=None, TimeBehind=None, Position=None, Status=None, Score=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
        self.TimeBehind = TimeBehind
        self.TimeBehind_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        self.Status = Status
        self.validate_ResultStatus(self.Status)
        self.Status_nsprefix_ = None
        if Score is None:
            self.Score = []
        else:
            self.Score = Score
        self.Score_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OverallResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OverallResult.subclass:
            return OverallResult.subclass(*args_, **kwargs_)
        else:
            return OverallResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_TimeBehind(self):
        return self.TimeBehind
    def set_TimeBehind(self, TimeBehind):
        self.TimeBehind = TimeBehind
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def add_Score(self, value):
        self.Score.append(value)
    def insert_Score_at(self, index, value):
        self.Score.insert(index, value)
    def replace_Score_at(self, index, value):
        self.Score[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def validate_ResultStatus(self, value):
        result = True
        # Validate type ResultStatus, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'Finished', 'MissingPunch', 'Disqualified', 'DidNotFinish', 'Active', 'Inactive', 'OverTime', 'SportingWithdrawal', 'NotCompeting', 'Moved', 'MovedUp', 'DidNotStart', 'DidNotEnter', 'Cancelled']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ResultStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Time is not None or
            self.TimeBehind is not None or
            self.Position is not None or
            self.Status is not None or
            self.Score or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OverallResult', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OverallResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OverallResult':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OverallResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OverallResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OverallResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OverallResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_double(self.Time, input_name='Time'), namespaceprefix_ , eol_))
        if self.TimeBehind is not None:
            namespaceprefix_ = self.TimeBehind_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeBehind_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeBehind>%s</%sTimeBehind>%s' % (namespaceprefix_ , self.gds_format_double(self.TimeBehind, input_name='TimeBehind'), namespaceprefix_ , eol_))
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition>%s</%sPosition>%s' % (namespaceprefix_ , self.gds_format_integer(self.Position, input_name='Position'), namespaceprefix_ , eol_))
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        for Score_ in self.Score:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            Score_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Score', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Time' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Time')
            fval_ = self.gds_validate_double(fval_, node, 'Time')
            self.Time = fval_
            self.Time_nsprefix_ = child_.prefix
        elif nodeName_ == 'TimeBehind' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'TimeBehind')
            fval_ = self.gds_validate_double(fval_, node, 'TimeBehind')
            self.TimeBehind = fval_
            self.TimeBehind_nsprefix_ = child_.prefix
        elif nodeName_ == 'Position' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Position')
            ival_ = self.gds_validate_integer(ival_, node, 'Position')
            self.Position = ival_
            self.Position_nsprefix_ = child_.prefix
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type ResultStatus
            self.validate_ResultStatus(self.Status)
        elif nodeName_ == 'Score':
            obj_ = Score.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Score.append(obj_)
            obj_.original_tagname_ = 'Score'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class OverallResult


class ControlAnswer(GeneratedsSuper):
    """Defines the the selected answer, the correct answer and the time used on
    a Trail-O control."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Answer=None, CorrectAnswer=None, Time=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Answer = Answer
        self.Answer_nsprefix_ = None
        self.CorrectAnswer = CorrectAnswer
        self.CorrectAnswer_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlAnswer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlAnswer.subclass:
            return ControlAnswer.subclass(*args_, **kwargs_)
        else:
            return ControlAnswer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Answer(self):
        return self.Answer
    def set_Answer(self, Answer):
        self.Answer = Answer
    def get_CorrectAnswer(self):
        return self.CorrectAnswer
    def set_CorrectAnswer(self, CorrectAnswer):
        self.CorrectAnswer = CorrectAnswer
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Answer is not None or
            self.CorrectAnswer is not None or
            self.Time is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ControlAnswer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ControlAnswer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ControlAnswer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlAnswer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ControlAnswer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ControlAnswer'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ControlAnswer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Answer is not None:
            namespaceprefix_ = self.Answer_nsprefix_ + ':' if (UseCapturedNS_ and self.Answer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnswer>%s</%sAnswer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Answer), input_name='Answer')), namespaceprefix_ , eol_))
        if self.CorrectAnswer is not None:
            namespaceprefix_ = self.CorrectAnswer_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrectAnswer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCorrectAnswer>%s</%sCorrectAnswer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CorrectAnswer), input_name='CorrectAnswer')), namespaceprefix_ , eol_))
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_double(self.Time, input_name='Time'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Answer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Answer')
            value_ = self.gds_validate_string(value_, node, 'Answer')
            self.Answer = value_
            self.Answer_nsprefix_ = child_.prefix
        elif nodeName_ == 'CorrectAnswer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CorrectAnswer')
            value_ = self.gds_validate_string(value_, node, 'CorrectAnswer')
            self.CorrectAnswer = value_
            self.CorrectAnswer_nsprefix_ = child_.prefix
        elif nodeName_ == 'Time' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Time')
            fval_ = self.gds_validate_double(fval_, node, 'Time')
            self.Time = fval_
            self.Time_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class ControlAnswer


class SplitTime(GeneratedsSuper):
    """Defines a split time at a control.
    The status of the split time."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, status='OK', ControlCode=None, Time=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.status = _cast(None, status)
        self.status_nsprefix_ = None
        self.ControlCode = ControlCode
        self.ControlCode_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplitTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplitTime.subclass:
            return SplitTime.subclass(*args_, **kwargs_)
        else:
            return SplitTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ControlCode(self):
        return self.ControlCode
    def set_ControlCode(self, ControlCode):
        self.ControlCode = ControlCode
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def validate_statusType7(self, value):
        # Validate type statusType7, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OK', 'Missing', 'Additional']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ControlCode is not None or
            self.Time is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='SplitTime', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplitTime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplitTime':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplitTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplitTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SplitTime'):
        if self.status != "OK" and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.status), input_name='status')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='SplitTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ControlCode is not None:
            namespaceprefix_ = self.ControlCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ControlCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControlCode>%s</%sControlCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ControlCode), input_name='ControlCode')), namespaceprefix_ , eol_))
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_double(self.Time, input_name='Time'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_statusType7(self.status)    # validate type statusType7
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ControlCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ControlCode')
            value_ = self.gds_validate_string(value_, node, 'ControlCode')
            self.ControlCode = value_
            self.ControlCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'Time' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Time')
            fval_ = self.gds_validate_double(fval_, node, 'Time')
            self.Time = fval_
            self.Time_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class SplitTime


class Route(GeneratedsSuper):
    """Defines a route, i.e. a number of geographical positions (waypoints)
    describing a competitor's navigation throughout a course.
    As routes contain large amounts of information, a compact storage format is
    utilized to keep the overall file size small. A route is stored as a
    base64-encoded byte sequence of waypoints. A waypoint is represented as
    described below. All multi-byte data types are stored in big-endian
    byte order (most significant byte first). Typically, a one-hour route
    with one-second waypoint recording interval occupies around 20
    kilobytes.
    Waypoint header byte
    ====================
    Each waypoint byte sequence starts with a waypoint header byte:
    Waypoint header byte, bit 1: Waypoint type. 0 for normal waypoint, 1 for
    interruption waypoint. An interruption waypoint is a waypoint that is
    the last waypoint before an interruption in the route occurs, e.g. due
    to a satellite signal receiving failure. The last waypoint of a route
    should be a normal waypoint, not an interruption waypoint.
    Waypoint header byte, bits 2 and 3: Time storage mode. For a description of
    the time storage modes, see below.
    Bit 2 Bit 3 Time storage mode
    0 0 full storage mode (6 bytes)
    1 0 milliseconds delta storage mode (2 bytes)
    0 1 seconds delta storage mode (1 byte)
    Waypoint header byte, bits 4 and 5: Position storage mode (latitude,
    longitude, and altitude (if present)). For a description of the
    position storage modes, see below.
    Bit 4 Bit 5 Position storage mode
    0 0 full storage mode (4 + 4 (+ 3) bytes for latitude, longitude and
    altitude (if present))
    1 0 big delta delta storage mode (2 + 2 (+ 1) bytes)
    0 1 small delta storage mode (1 + 1 (+ 1) bytes)
    Waypoint header byte, bit 6: Altitude presence. 0 if an altitude value is
    not present, 1 if it is present.
    Waypoint header byte, bit 7: Unused, always 0.
    Waypoint header byte, bit 8: Unused, always 0.
    Time byte sequence
    ==================
    After the waypoint byte comes the time byte sequence. Depending on the time
    storage mode defined in the waypoint header, the time byte sequence is
    either 6 bytes (full), 2 bytes (milliseconds delta) or 1 byte (seconds
    delta) long.
    Full storage mode
    -----------------
    The following 6 bytes are an unsigned 48-bit integer defining the
    waypoint's time as the number of milliseconds (1/1000 seconds) since
    January 1, 1900, 00:00:00 UTC.
    Milliseconds delta storage mode
    -------------------------------
    The following 2 bytes are an unsigned 16-bit integer defining the
    waypoint's time as the number of milliseconds to add to the last
    waypoint's time.
    Seconds delta storage mode
    --------------------------
    The following byte is an unsigned 8-bit integer defining the waypoint's
    time as the number of seconds to add to the last waypoint's time. This
    storage mody can only be used when the difference to the last
    waypoint's time is an integer value.
    Consequently:
    - seconds delta storage mode is used when the waypoint's time is less than
    256 seconds later than the last waypoint's time, and the difference
    between the times is an integer value.
    - milliseconds delta storage mode is used when the waypoint's time is less
    than 65.536 seconds later than the last waypoint's time
    - otherwise, full storage mode is used
    The time of the first waypoint of a route is always stored in full storage
    mode.
    Position byte sequence
    ======================
    Next, the position byte sequence appears: latitude, longitude and (if
    present) altitude bytes. Depending on the position storage mode defined
    in the waypoint header, the position byte sequence is either 4 + 4 (+
    3) bytes (full), 2 + 2 (+ 1) bytes (big delta) or 1 + 1 (+ 1) bytes
    (small delta) long.
    Full storage mode
    -----------------
    The first 4 bytes are a signed 32-bit integer defining the waypoint's
    latitude as microdegrees (1/1000000 degrees) relative to the equator. A
    negative value implies a latitude south of the equator. A microdegree
    is approximately equivalent to 0.1 meters.
    The following 4 bytes are a signed 32-bit integer defining the waypoint's
    latitude as microdegrees (1/1000000 degrees) relative to the Greenwich
    meridian. A negative value implies a longitude west of the Greenwich
    meridian. A microdegree is approximately equivalent to 0.1 meters at
    the equator and infinitely small at the poles.
    If the altitude presence bit in the waypoint header bit is set to 1, the
    following 3 bytes are a signed 24-bit integer defining the waypoint's
    altitude as decimeters (1/10 meters) relative to the sea level.
    Big delta storage mode
    ----------------------
    The first 2 bytes are a signed 16-bit integer defining the waypoint's
    latitude as the number of microdegrees to add to the last waypoint's
    latitude.
    The following 2 bytes are a signed 16-bit integer defining the waypoint's
    longitude as the number of microdegrees to add to the last waypoint's
    longitude.
    If the altitude presence bit in the waypoint header bit is set to 1, the
    following byte is a signed 8-bit integer defining the waypoint's
    altitude as the number of decimeters to add to the last waypoint's
    altitude.
    Small delta storage mode
    ----------------------
    The first byte is a signed 8-bit integer defining the waypoint's latitude
    as the number of microdegrees to add to the last waypoint's latitude.
    The following byte is a signed 8-bit integer defining the waypoint's
    longitude as the number of microdegrees to add to the last waypoint's
    longitude.
    If the altitude presence bit in the waypoint header bit is set to 1, the
    following byte is a signed 8-bit integer defining the waypoint's
    altitude as the number of decimeters to add to the last waypoint's
    altitude.
    Consequently:
    - small delta storage mode is used when the waypoint's latitude and
    longitude is within -0.000128 to 0.000127 degrees from the last
    waypoint's latitude, and when the altitude is not present or is within
    -12.8 to 12.7 meters from the last waypoint's altitude
    - big delta storage mode is used when the waypoint's latitude and longitude
    is within -0.032768 to 0.032767 degrees from the last waypoint's
    latitude, and when the altitude is not present or is within -12.8 to
    12.7 meters from the last waypoint's altitude
    - otherwise, full storage mode is used
    The position of the first waypoint of a route is always stored in full
    storage mode.
    Code libraries for reading and writing route data is found in
    https://github.com/international-orienteering-
    federation/datastandard-v3/tree/master/libraries."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Route)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Route.subclass:
            return Route.subclass(*args_, **kwargs_)
        else:
            return Route(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Route', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Route')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Route':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Route')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Route', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Route'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Route', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Route


class Leg(GeneratedsSuper):
    """Defines extra information for a relay leg.
    The minimum number of competitors in case of a parallel leg.
    The maximum number of competitors in case of a parallel leg."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, minNumberOfCompetitors=1, maxNumberOfCompetitors=1, Name=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minNumberOfCompetitors = _cast(int, minNumberOfCompetitors)
        self.minNumberOfCompetitors_nsprefix_ = None
        self.maxNumberOfCompetitors = _cast(int, maxNumberOfCompetitors)
        self.maxNumberOfCompetitors_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Leg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Leg.subclass:
            return Leg.subclass(*args_, **kwargs_)
        else:
            return Leg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_minNumberOfCompetitors(self):
        return self.minNumberOfCompetitors
    def set_minNumberOfCompetitors(self, minNumberOfCompetitors):
        self.minNumberOfCompetitors = minNumberOfCompetitors
    def get_maxNumberOfCompetitors(self):
        return self.maxNumberOfCompetitors
    def set_maxNumberOfCompetitors(self, maxNumberOfCompetitors):
        self.maxNumberOfCompetitors = maxNumberOfCompetitors
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Leg', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Leg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Leg':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Leg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Leg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Leg'):
        if self.minNumberOfCompetitors != 1 and 'minNumberOfCompetitors' not in already_processed:
            already_processed.add('minNumberOfCompetitors')
            outfile.write(' minNumberOfCompetitors="%s"' % self.gds_format_integer(self.minNumberOfCompetitors, input_name='minNumberOfCompetitors'))
        if self.maxNumberOfCompetitors != 1 and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            outfile.write(' maxNumberOfCompetitors="%s"' % self.gds_format_integer(self.maxNumberOfCompetitors, input_name='maxNumberOfCompetitors'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Leg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minNumberOfCompetitors', node)
        if value is not None and 'minNumberOfCompetitors' not in already_processed:
            already_processed.add('minNumberOfCompetitors')
            self.minNumberOfCompetitors = self.gds_parse_integer(value, node, 'minNumberOfCompetitors')
        value = find_attr_value_('maxNumberOfCompetitors', node)
        if value is not None and 'maxNumberOfCompetitors' not in already_processed:
            already_processed.add('maxNumberOfCompetitors')
            self.maxNumberOfCompetitors = self.gds_parse_integer(value, node, 'maxNumberOfCompetitors')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Leg


class Control(GeneratedsSuper):
    """Defines a control, without any relationship to a particular course.
    The type of the control: (ordinary) control, start, finish, crossing point
    or end of marked route. This attribute can be overridden on the
    CourseControl level."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_='Control', modifyTime=None, Id=None, PunchingUnitId=None, Name=None, Position=None, MapPosition=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        if PunchingUnitId is None:
            self.PunchingUnitId = []
        else:
            self.PunchingUnitId = PunchingUnitId
        self.PunchingUnitId_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        self.MapPosition = MapPosition
        self.MapPosition_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Control)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Control.subclass:
            return Control.subclass(*args_, **kwargs_)
        else:
            return Control(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_PunchingUnitId(self):
        return self.PunchingUnitId
    def set_PunchingUnitId(self, PunchingUnitId):
        self.PunchingUnitId = PunchingUnitId
    def add_PunchingUnitId(self, value):
        self.PunchingUnitId.append(value)
    def insert_PunchingUnitId_at(self, index, value):
        self.PunchingUnitId.insert(index, value)
    def replace_PunchingUnitId_at(self, index, value):
        self.PunchingUnitId[index] = value
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def add_Name(self, value):
        self.Name.append(value)
    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)
    def replace_Name_at(self, index, value):
        self.Name[index] = value
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_MapPosition(self):
        return self.MapPosition
    def set_MapPosition(self, MapPosition):
        self.MapPosition = MapPosition
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_ControlType(self, value):
        # Validate type ControlType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Control', 'Start', 'Finish', 'CrossingPoint', 'EndOfMarkedRoute']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ControlType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Id is not None or
            self.PunchingUnitId or
            self.Name or
            self.Position is not None or
            self.MapPosition is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Control', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Control')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Control':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Control')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Control', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Control'):
        if self.type_ != "Control" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Control', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        for PunchingUnitId_ in self.PunchingUnitId:
            namespaceprefix_ = self.PunchingUnitId_nsprefix_ + ':' if (UseCapturedNS_ and self.PunchingUnitId_nsprefix_) else ''
            PunchingUnitId_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PunchingUnitId', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            self.Position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        if self.MapPosition is not None:
            namespaceprefix_ = self.MapPosition_nsprefix_ + ':' if (UseCapturedNS_ and self.MapPosition_nsprefix_) else ''
            self.MapPosition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapPosition', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_ControlType(self.type_)    # validate type ControlType
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'PunchingUnitId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PunchingUnitId.append(obj_)
            obj_.original_tagname_ = 'PunchingUnitId'
        elif nodeName_ == 'Name':
            obj_ = LanguageString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Position':
            obj_ = GeoPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'MapPosition':
            obj_ = MapPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapPosition = obj_
            obj_.original_tagname_ = 'MapPosition'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Control


class GeoPosition(GeneratedsSuper):
    """Defines a geographical position, e.g. of a control.
    The longitude.
    The latitude.
    The altitude (elevation above sea level), in meters."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lng=None, lat=None, alt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lng = _cast(float, lng)
        self.lng_nsprefix_ = None
        self.lat = _cast(float, lat)
        self.lat_nsprefix_ = None
        self.alt = _cast(float, alt)
        self.alt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeoPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeoPosition.subclass:
            return GeoPosition.subclass(*args_, **kwargs_)
        else:
            return GeoPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lng(self):
        return self.lng
    def set_lng(self, lng):
        self.lng = lng
    def get_lat(self):
        return self.lat
    def set_lat(self, lat):
        self.lat = lat
    def get_alt(self):
        return self.alt
    def set_alt(self, alt):
        self.alt = alt
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GeoPosition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeoPosition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeoPosition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeoPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeoPosition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeoPosition'):
        if self.lng is not None and 'lng' not in already_processed:
            already_processed.add('lng')
            outfile.write(' lng="%s"' % self.gds_format_double(self.lng, input_name='lng'))
        if self.lat is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            outfile.write(' lat="%s"' % self.gds_format_double(self.lat, input_name='lat'))
        if self.alt is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            outfile.write(' alt="%s"' % self.gds_format_double(self.alt, input_name='alt'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GeoPosition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lng', node)
        if value is not None and 'lng' not in already_processed:
            already_processed.add('lng')
            value = self.gds_parse_double(value, node, 'lng')
            self.lng = value
        value = find_attr_value_('lat', node)
        if value is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            value = self.gds_parse_double(value, node, 'lat')
            self.lat = value
        value = find_attr_value_('alt', node)
        if value is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            value = self.gds_parse_double(value, node, 'alt')
            self.alt = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GeoPosition


class Map(GeneratedsSuper):
    """Map information, used in course setting software with regard to the
    "real" map."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, Image=None, Scale=None, MapPositionTopLeft=None, MapPositionBottomRight=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Image = Image
        self.Image_nsprefix_ = None
        self.Scale = Scale
        self.Scale_nsprefix_ = None
        self.MapPositionTopLeft = MapPositionTopLeft
        self.MapPositionTopLeft_nsprefix_ = None
        self.MapPositionBottomRight = MapPositionBottomRight
        self.MapPositionBottomRight_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Map)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Map.subclass:
            return Map.subclass(*args_, **kwargs_)
        else:
            return Map(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Image(self):
        return self.Image
    def set_Image(self, Image):
        self.Image = Image
    def get_Scale(self):
        return self.Scale
    def set_Scale(self, Scale):
        self.Scale = Scale
    def get_MapPositionTopLeft(self):
        return self.MapPositionTopLeft
    def set_MapPositionTopLeft(self, MapPositionTopLeft):
        self.MapPositionTopLeft = MapPositionTopLeft
    def get_MapPositionBottomRight(self):
        return self.MapPositionBottomRight
    def set_MapPositionBottomRight(self, MapPositionBottomRight):
        self.MapPositionBottomRight = MapPositionBottomRight
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Image is not None or
            self.Scale is not None or
            self.MapPositionTopLeft is not None or
            self.MapPositionBottomRight is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Map', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Map')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Map':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Map')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Map', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Map'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Map', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Image is not None:
            namespaceprefix_ = self.Image_nsprefix_ + ':' if (UseCapturedNS_ and self.Image_nsprefix_) else ''
            self.Image.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Image', pretty_print=pretty_print)
        if self.Scale is not None:
            namespaceprefix_ = self.Scale_nsprefix_ + ':' if (UseCapturedNS_ and self.Scale_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScale>%s</%sScale>%s' % (namespaceprefix_ , self.gds_format_double(self.Scale, input_name='Scale'), namespaceprefix_ , eol_))
        if self.MapPositionTopLeft is not None:
            namespaceprefix_ = self.MapPositionTopLeft_nsprefix_ + ':' if (UseCapturedNS_ and self.MapPositionTopLeft_nsprefix_) else ''
            self.MapPositionTopLeft.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapPositionTopLeft', pretty_print=pretty_print)
        if self.MapPositionBottomRight is not None:
            namespaceprefix_ = self.MapPositionBottomRight_nsprefix_ + ':' if (UseCapturedNS_ and self.MapPositionBottomRight_nsprefix_) else ''
            self.MapPositionBottomRight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapPositionBottomRight', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Image':
            obj_ = Image.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Image = obj_
            obj_.original_tagname_ = 'Image'
        elif nodeName_ == 'Scale' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Scale')
            fval_ = self.gds_validate_double(fval_, node, 'Scale')
            self.Scale = fval_
            self.Scale_nsprefix_ = child_.prefix
        elif nodeName_ == 'MapPositionTopLeft':
            obj_ = MapPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapPositionTopLeft = obj_
            obj_.original_tagname_ = 'MapPositionTopLeft'
        elif nodeName_ == 'MapPositionBottomRight':
            obj_ = MapPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapPositionBottomRight = obj_
            obj_.original_tagname_ = 'MapPositionBottomRight'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Map


class Image(GeneratedsSuper):
    """Defines an image file, either as a link (use the url attribute) or as
    base64-encoded binary data.
    The url to the image if it is stored externally (i.e. not as base64-encoded
    binary data).
    The type of the image file, e.g. image/jpeg. Refer to
    https://www.iana.org/assignments/media-types/media-types.xhtml#image
    for available media types.
    The width of the image in pixels.
    The height of the image in pixels.
    The resolution of the image in dpi."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, url=None, mediaType=None, width=None, height=None, resolution=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.url = _cast(None, url)
        self.url_nsprefix_ = None
        self.mediaType = _cast(None, mediaType)
        self.mediaType_nsprefix_ = None
        self.width = _cast(int, width)
        self.width_nsprefix_ = None
        self.height = _cast(int, height)
        self.height_nsprefix_ = None
        self.resolution = _cast(float, resolution)
        self.resolution_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_mediaType(self):
        return self.mediaType
    def set_mediaType(self, mediaType):
        self.mediaType = mediaType
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_resolution(self):
        return self.resolution
    def set_resolution(self, resolution):
        self.resolution = resolution
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Image', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Image':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Image', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Image'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')), ))
        if self.mediaType is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            outfile.write(' mediaType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mediaType), input_name='mediaType')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
        if self.resolution is not None and 'resolution' not in already_processed:
            already_processed.add('resolution')
            outfile.write(' resolution="%s"' % self.gds_format_double(self.resolution, input_name='resolution'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Image', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('mediaType', node)
        if value is not None and 'mediaType' not in already_processed:
            already_processed.add('mediaType')
            self.mediaType = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = self.gds_parse_integer(value, node, 'width')
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = self.gds_parse_integer(value, node, 'height')
        value = find_attr_value_('resolution', node)
        if value is not None and 'resolution' not in already_processed:
            already_processed.add('resolution')
            value = self.gds_parse_double(value, node, 'resolution')
            self.resolution = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Image


class MapPosition(GeneratedsSuper):
    """Defines a position in a map's coordinate system.
    The number of units right of the center of the coordinate system.
    The number of units below the center of the coordinate system.
    The type of unit used."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, unit='mm', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(float, x)
        self.x_nsprefix_ = None
        self.y = _cast(float, y)
        self.y_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MapPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MapPosition.subclass:
            return MapPosition.subclass(*args_, **kwargs_)
        else:
            return MapPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def validate_unitType(self, value):
        # Validate type unitType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['px', 'mm']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on unitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MapPosition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MapPosition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MapPosition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MapPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MapPosition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MapPosition'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.unit != "mm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MapPosition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            value = self.gds_parse_double(value, node, 'x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            value = self.gds_parse_double(value, node, 'y')
            self.y = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_unitType(self.unit)    # validate type unitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MapPosition


class RaceCourseData(GeneratedsSuper):
    """This element defines all the control and course information for a race.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, raceNumber=None, Map=None, Control=None, Course=None, ClassCourseAssignment=None, PersonCourseAssignment=None, TeamCourseAssignment=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
        if Map is None:
            self.Map = []
        else:
            self.Map = Map
        self.Map_nsprefix_ = None
        if Control is None:
            self.Control = []
        else:
            self.Control = Control
        self.Control_nsprefix_ = None
        if Course is None:
            self.Course = []
        else:
            self.Course = Course
        self.Course_nsprefix_ = None
        if ClassCourseAssignment is None:
            self.ClassCourseAssignment = []
        else:
            self.ClassCourseAssignment = ClassCourseAssignment
        self.ClassCourseAssignment_nsprefix_ = None
        if PersonCourseAssignment is None:
            self.PersonCourseAssignment = []
        else:
            self.PersonCourseAssignment = PersonCourseAssignment
        self.PersonCourseAssignment_nsprefix_ = None
        if TeamCourseAssignment is None:
            self.TeamCourseAssignment = []
        else:
            self.TeamCourseAssignment = TeamCourseAssignment
        self.TeamCourseAssignment_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RaceCourseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RaceCourseData.subclass:
            return RaceCourseData.subclass(*args_, **kwargs_)
        else:
            return RaceCourseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Map(self):
        return self.Map
    def set_Map(self, Map):
        self.Map = Map
    def add_Map(self, value):
        self.Map.append(value)
    def insert_Map_at(self, index, value):
        self.Map.insert(index, value)
    def replace_Map_at(self, index, value):
        self.Map[index] = value
    def get_Control(self):
        return self.Control
    def set_Control(self, Control):
        self.Control = Control
    def add_Control(self, value):
        self.Control.append(value)
    def insert_Control_at(self, index, value):
        self.Control.insert(index, value)
    def replace_Control_at(self, index, value):
        self.Control[index] = value
    def get_Course(self):
        return self.Course
    def set_Course(self, Course):
        self.Course = Course
    def add_Course(self, value):
        self.Course.append(value)
    def insert_Course_at(self, index, value):
        self.Course.insert(index, value)
    def replace_Course_at(self, index, value):
        self.Course[index] = value
    def get_ClassCourseAssignment(self):
        return self.ClassCourseAssignment
    def set_ClassCourseAssignment(self, ClassCourseAssignment):
        self.ClassCourseAssignment = ClassCourseAssignment
    def add_ClassCourseAssignment(self, value):
        self.ClassCourseAssignment.append(value)
    def insert_ClassCourseAssignment_at(self, index, value):
        self.ClassCourseAssignment.insert(index, value)
    def replace_ClassCourseAssignment_at(self, index, value):
        self.ClassCourseAssignment[index] = value
    def get_PersonCourseAssignment(self):
        return self.PersonCourseAssignment
    def set_PersonCourseAssignment(self, PersonCourseAssignment):
        self.PersonCourseAssignment = PersonCourseAssignment
    def add_PersonCourseAssignment(self, value):
        self.PersonCourseAssignment.append(value)
    def insert_PersonCourseAssignment_at(self, index, value):
        self.PersonCourseAssignment.insert(index, value)
    def replace_PersonCourseAssignment_at(self, index, value):
        self.PersonCourseAssignment[index] = value
    def get_TeamCourseAssignment(self):
        return self.TeamCourseAssignment
    def set_TeamCourseAssignment(self, TeamCourseAssignment):
        self.TeamCourseAssignment = TeamCourseAssignment
    def add_TeamCourseAssignment(self, value):
        self.TeamCourseAssignment.append(value)
    def insert_TeamCourseAssignment_at(self, index, value):
        self.TeamCourseAssignment.insert(index, value)
    def replace_TeamCourseAssignment_at(self, index, value):
        self.TeamCourseAssignment[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def hasContent_(self):
        if (
            self.Map or
            self.Control or
            self.Course or
            self.ClassCourseAssignment or
            self.PersonCourseAssignment or
            self.TeamCourseAssignment or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='RaceCourseData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RaceCourseData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RaceCourseData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RaceCourseData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RaceCourseData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RaceCourseData'):
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='RaceCourseData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Map_ in self.Map:
            namespaceprefix_ = self.Map_nsprefix_ + ':' if (UseCapturedNS_ and self.Map_nsprefix_) else ''
            Map_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Map', pretty_print=pretty_print)
        for Control_ in self.Control:
            namespaceprefix_ = self.Control_nsprefix_ + ':' if (UseCapturedNS_ and self.Control_nsprefix_) else ''
            Control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Control', pretty_print=pretty_print)
        for Course_ in self.Course:
            namespaceprefix_ = self.Course_nsprefix_ + ':' if (UseCapturedNS_ and self.Course_nsprefix_) else ''
            Course_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Course', pretty_print=pretty_print)
        for ClassCourseAssignment_ in self.ClassCourseAssignment:
            namespaceprefix_ = self.ClassCourseAssignment_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassCourseAssignment_nsprefix_) else ''
            ClassCourseAssignment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassCourseAssignment', pretty_print=pretty_print)
        for PersonCourseAssignment_ in self.PersonCourseAssignment:
            namespaceprefix_ = self.PersonCourseAssignment_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonCourseAssignment_nsprefix_) else ''
            PersonCourseAssignment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonCourseAssignment', pretty_print=pretty_print)
        for TeamCourseAssignment_ in self.TeamCourseAssignment:
            namespaceprefix_ = self.TeamCourseAssignment_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamCourseAssignment_nsprefix_) else ''
            TeamCourseAssignment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamCourseAssignment', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Map':
            obj_ = Map.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Map.append(obj_)
            obj_.original_tagname_ = 'Map'
        elif nodeName_ == 'Control':
            obj_ = Control.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Control.append(obj_)
            obj_.original_tagname_ = 'Control'
        elif nodeName_ == 'Course':
            obj_ = Course.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Course.append(obj_)
            obj_.original_tagname_ = 'Course'
        elif nodeName_ == 'ClassCourseAssignment':
            obj_ = ClassCourseAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassCourseAssignment.append(obj_)
            obj_.original_tagname_ = 'ClassCourseAssignment'
        elif nodeName_ == 'PersonCourseAssignment':
            obj_ = PersonCourseAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonCourseAssignment.append(obj_)
            obj_.original_tagname_ = 'PersonCourseAssignment'
        elif nodeName_ == 'TeamCourseAssignment':
            obj_ = TeamCourseAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamCourseAssignment.append(obj_)
            obj_.original_tagname_ = 'TeamCourseAssignment'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class RaceCourseData


class ClassCourseAssignment(GeneratedsSuper):
    """Element that connects a course with a class. Courses should be present
    in the RaceCourseData element and are matched on course name and/or
    course family. Classes are matched by 1) Id, 2) Name.
    The number of competitors in the class. A competitor corresponds to a
    person (if an individual event) or a team (if a team or relay
    event)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfCompetitors=None, ClassId=None, ClassName=None, AllowedOnLeg=None, CourseName=None, CourseFamily=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfCompetitors = _cast(int, numberOfCompetitors)
        self.numberOfCompetitors_nsprefix_ = None
        self.ClassId = ClassId
        self.ClassId_nsprefix_ = None
        self.ClassName = ClassName
        self.ClassName_nsprefix_ = None
        if AllowedOnLeg is None:
            self.AllowedOnLeg = []
        else:
            self.AllowedOnLeg = AllowedOnLeg
        self.AllowedOnLeg_nsprefix_ = None
        self.CourseName = CourseName
        self.CourseName_nsprefix_ = None
        self.CourseFamily = CourseFamily
        self.CourseFamily_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassCourseAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassCourseAssignment.subclass:
            return ClassCourseAssignment.subclass(*args_, **kwargs_)
        else:
            return ClassCourseAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ClassId(self):
        return self.ClassId
    def set_ClassId(self, ClassId):
        self.ClassId = ClassId
    def get_ClassName(self):
        return self.ClassName
    def set_ClassName(self, ClassName):
        self.ClassName = ClassName
    def get_AllowedOnLeg(self):
        return self.AllowedOnLeg
    def set_AllowedOnLeg(self, AllowedOnLeg):
        self.AllowedOnLeg = AllowedOnLeg
    def add_AllowedOnLeg(self, value):
        self.AllowedOnLeg.append(value)
    def insert_AllowedOnLeg_at(self, index, value):
        self.AllowedOnLeg.insert(index, value)
    def replace_AllowedOnLeg_at(self, index, value):
        self.AllowedOnLeg[index] = value
    def get_CourseName(self):
        return self.CourseName
    def set_CourseName(self, CourseName):
        self.CourseName = CourseName
    def get_CourseFamily(self):
        return self.CourseFamily
    def set_CourseFamily(self, CourseFamily):
        self.CourseFamily = CourseFamily
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_numberOfCompetitors(self):
        return self.numberOfCompetitors
    def set_numberOfCompetitors(self, numberOfCompetitors):
        self.numberOfCompetitors = numberOfCompetitors
    def hasContent_(self):
        if (
            self.ClassId is not None or
            self.ClassName is not None or
            self.AllowedOnLeg or
            self.CourseName is not None or
            self.CourseFamily is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassCourseAssignment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassCourseAssignment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassCourseAssignment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassCourseAssignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassCourseAssignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassCourseAssignment'):
        if self.numberOfCompetitors is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            outfile.write(' numberOfCompetitors="%s"' % self.gds_format_integer(self.numberOfCompetitors, input_name='numberOfCompetitors'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ClassCourseAssignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClassId is not None:
            namespaceprefix_ = self.ClassId_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassId_nsprefix_) else ''
            self.ClassId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassId', pretty_print=pretty_print)
        if self.ClassName is not None:
            namespaceprefix_ = self.ClassName_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassName>%s</%sClassName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ClassName), input_name='ClassName')), namespaceprefix_ , eol_))
        for AllowedOnLeg_ in self.AllowedOnLeg:
            namespaceprefix_ = self.AllowedOnLeg_nsprefix_ + ':' if (UseCapturedNS_ and self.AllowedOnLeg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllowedOnLeg>%s</%sAllowedOnLeg>%s' % (namespaceprefix_ , self.gds_format_integer(AllowedOnLeg_, input_name='AllowedOnLeg'), namespaceprefix_ , eol_))
        if self.CourseName is not None:
            namespaceprefix_ = self.CourseName_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseName>%s</%sCourseName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseName), input_name='CourseName')), namespaceprefix_ , eol_))
        if self.CourseFamily is not None:
            namespaceprefix_ = self.CourseFamily_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseFamily_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseFamily>%s</%sCourseFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseFamily), input_name='CourseFamily')), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfCompetitors', node)
        if value is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            self.numberOfCompetitors = self.gds_parse_integer(value, node, 'numberOfCompetitors')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ClassId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassId = obj_
            obj_.original_tagname_ = 'ClassId'
        elif nodeName_ == 'ClassName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ClassName')
            value_ = self.gds_validate_string(value_, node, 'ClassName')
            self.ClassName = value_
            self.ClassName_nsprefix_ = child_.prefix
        elif nodeName_ == 'AllowedOnLeg' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'AllowedOnLeg')
            ival_ = self.gds_validate_integer(ival_, node, 'AllowedOnLeg')
            self.AllowedOnLeg.append(ival_)
            self.AllowedOnLeg_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseName')
            value_ = self.gds_validate_string(value_, node, 'CourseName')
            self.CourseName = value_
            self.CourseName_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseFamily')
            value_ = self.gds_validate_string(value_, node, 'CourseFamily')
            self.CourseFamily = value_
            self.CourseFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class ClassCourseAssignment


class PersonCourseAssignment(GeneratedsSuper):
    """Element that connects a course with an individual competitor. Courses
    should be present in the RaceCourseData element and are matched on
    course name and/or course family. Persons are matched by 1) BibNumber,
    2) EntryId."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EntryId=None, BibNumber=None, PersonName=None, ClassName=None, CourseName=None, CourseFamily=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        self.PersonName = PersonName
        self.PersonName_nsprefix_ = None
        self.ClassName = ClassName
        self.ClassName_nsprefix_ = None
        self.CourseName = CourseName
        self.CourseName_nsprefix_ = None
        self.CourseFamily = CourseFamily
        self.CourseFamily_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonCourseAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonCourseAssignment.subclass:
            return PersonCourseAssignment.subclass(*args_, **kwargs_)
        else:
            return PersonCourseAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_PersonName(self):
        return self.PersonName
    def set_PersonName(self, PersonName):
        self.PersonName = PersonName
    def get_ClassName(self):
        return self.ClassName
    def set_ClassName(self, ClassName):
        self.ClassName = ClassName
    def get_CourseName(self):
        return self.CourseName
    def set_CourseName(self, CourseName):
        self.CourseName = CourseName
    def get_CourseFamily(self):
        return self.CourseFamily
    def set_CourseFamily(self, CourseFamily):
        self.CourseFamily = CourseFamily
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.BibNumber is not None or
            self.PersonName is not None or
            self.ClassName is not None or
            self.CourseName is not None or
            self.CourseFamily is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonCourseAssignment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonCourseAssignment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonCourseAssignment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonCourseAssignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonCourseAssignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonCourseAssignment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonCourseAssignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.PersonName is not None:
            namespaceprefix_ = self.PersonName_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonName>%s</%sPersonName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PersonName), input_name='PersonName')), namespaceprefix_ , eol_))
        if self.ClassName is not None:
            namespaceprefix_ = self.ClassName_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassName>%s</%sClassName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ClassName), input_name='ClassName')), namespaceprefix_ , eol_))
        if self.CourseName is not None:
            namespaceprefix_ = self.CourseName_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseName>%s</%sCourseName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseName), input_name='CourseName')), namespaceprefix_ , eol_))
        if self.CourseFamily is not None:
            namespaceprefix_ = self.CourseFamily_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseFamily_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseFamily>%s</%sCourseFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseFamily), input_name='CourseFamily')), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'PersonName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonName')
            value_ = self.gds_validate_string(value_, node, 'PersonName')
            self.PersonName = value_
            self.PersonName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ClassName')
            value_ = self.gds_validate_string(value_, node, 'ClassName')
            self.ClassName = value_
            self.ClassName_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseName')
            value_ = self.gds_validate_string(value_, node, 'CourseName')
            self.CourseName = value_
            self.CourseName_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseFamily')
            value_ = self.gds_validate_string(value_, node, 'CourseFamily')
            self.CourseFamily = value_
            self.CourseFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class PersonCourseAssignment


class TeamCourseAssignment(GeneratedsSuper):
    """Element that connects a number of team members in a relay team to a
    number of courses. Teams are matched by 1) BibNumber, 2)
    TeamName+ClassName."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BibNumber=None, TeamName=None, ClassName=None, TeamMemberCourseAssignment=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        self.TeamName = TeamName
        self.TeamName_nsprefix_ = None
        self.ClassName = ClassName
        self.ClassName_nsprefix_ = None
        if TeamMemberCourseAssignment is None:
            self.TeamMemberCourseAssignment = []
        else:
            self.TeamMemberCourseAssignment = TeamMemberCourseAssignment
        self.TeamMemberCourseAssignment_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamCourseAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamCourseAssignment.subclass:
            return TeamCourseAssignment.subclass(*args_, **kwargs_)
        else:
            return TeamCourseAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_TeamName(self):
        return self.TeamName
    def set_TeamName(self, TeamName):
        self.TeamName = TeamName
    def get_ClassName(self):
        return self.ClassName
    def set_ClassName(self, ClassName):
        self.ClassName = ClassName
    def get_TeamMemberCourseAssignment(self):
        return self.TeamMemberCourseAssignment
    def set_TeamMemberCourseAssignment(self, TeamMemberCourseAssignment):
        self.TeamMemberCourseAssignment = TeamMemberCourseAssignment
    def add_TeamMemberCourseAssignment(self, value):
        self.TeamMemberCourseAssignment.append(value)
    def insert_TeamMemberCourseAssignment_at(self, index, value):
        self.TeamMemberCourseAssignment.insert(index, value)
    def replace_TeamMemberCourseAssignment_at(self, index, value):
        self.TeamMemberCourseAssignment[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.BibNumber is not None or
            self.TeamName is not None or
            self.ClassName is not None or
            self.TeamMemberCourseAssignment or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamCourseAssignment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamCourseAssignment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamCourseAssignment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamCourseAssignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamCourseAssignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamCourseAssignment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamCourseAssignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.TeamName is not None:
            namespaceprefix_ = self.TeamName_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTeamName>%s</%sTeamName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TeamName), input_name='TeamName')), namespaceprefix_ , eol_))
        if self.ClassName is not None:
            namespaceprefix_ = self.ClassName_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassName>%s</%sClassName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ClassName), input_name='ClassName')), namespaceprefix_ , eol_))
        for TeamMemberCourseAssignment_ in self.TeamMemberCourseAssignment:
            namespaceprefix_ = self.TeamMemberCourseAssignment_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamMemberCourseAssignment_nsprefix_) else ''
            TeamMemberCourseAssignment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TeamMemberCourseAssignment', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TeamName')
            value_ = self.gds_validate_string(value_, node, 'TeamName')
            self.TeamName = value_
            self.TeamName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ClassName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ClassName')
            value_ = self.gds_validate_string(value_, node, 'ClassName')
            self.ClassName = value_
            self.ClassName_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamMemberCourseAssignment':
            obj_ = TeamMemberCourseAssignment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TeamMemberCourseAssignment.append(obj_)
            obj_.original_tagname_ = 'TeamMemberCourseAssignment'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamCourseAssignment


class TeamMemberCourseAssignment(GeneratedsSuper):
    """Element that connects a course with a relay team member. Courses should
    be present in the RaceCourseData element and are matched on course name
    and/or course family. Team members are matched by 1) BibNumber, 2) Leg
    and LegOrder, 3) EntryId."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EntryId=None, BibNumber=None, Leg=None, LegOrder=None, TeamMemberName=None, CourseName=None, CourseFamily=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.EntryId = EntryId
        self.EntryId_nsprefix_ = None
        self.BibNumber = BibNumber
        self.BibNumber_nsprefix_ = None
        self.Leg = Leg
        self.Leg_nsprefix_ = None
        self.LegOrder = LegOrder
        self.LegOrder_nsprefix_ = None
        self.TeamMemberName = TeamMemberName
        self.TeamMemberName_nsprefix_ = None
        self.CourseName = CourseName
        self.CourseName_nsprefix_ = None
        self.CourseFamily = CourseFamily
        self.CourseFamily_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TeamMemberCourseAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TeamMemberCourseAssignment.subclass:
            return TeamMemberCourseAssignment.subclass(*args_, **kwargs_)
        else:
            return TeamMemberCourseAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EntryId(self):
        return self.EntryId
    def set_EntryId(self, EntryId):
        self.EntryId = EntryId
    def get_BibNumber(self):
        return self.BibNumber
    def set_BibNumber(self, BibNumber):
        self.BibNumber = BibNumber
    def get_Leg(self):
        return self.Leg
    def set_Leg(self, Leg):
        self.Leg = Leg
    def get_LegOrder(self):
        return self.LegOrder
    def set_LegOrder(self, LegOrder):
        self.LegOrder = LegOrder
    def get_TeamMemberName(self):
        return self.TeamMemberName
    def set_TeamMemberName(self, TeamMemberName):
        self.TeamMemberName = TeamMemberName
    def get_CourseName(self):
        return self.CourseName
    def set_CourseName(self, CourseName):
        self.CourseName = CourseName
    def get_CourseFamily(self):
        return self.CourseFamily
    def set_CourseFamily(self, CourseFamily):
        self.CourseFamily = CourseFamily
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def hasContent_(self):
        if (
            self.EntryId is not None or
            self.BibNumber is not None or
            self.Leg is not None or
            self.LegOrder is not None or
            self.TeamMemberName is not None or
            self.CourseName is not None or
            self.CourseFamily is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberCourseAssignment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TeamMemberCourseAssignment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TeamMemberCourseAssignment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TeamMemberCourseAssignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TeamMemberCourseAssignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TeamMemberCourseAssignment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='TeamMemberCourseAssignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryId is not None:
            namespaceprefix_ = self.EntryId_nsprefix_ + ':' if (UseCapturedNS_ and self.EntryId_nsprefix_) else ''
            self.EntryId.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EntryId', pretty_print=pretty_print)
        if self.BibNumber is not None:
            namespaceprefix_ = self.BibNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.BibNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBibNumber>%s</%sBibNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BibNumber), input_name='BibNumber')), namespaceprefix_ , eol_))
        if self.Leg is not None:
            namespaceprefix_ = self.Leg_nsprefix_ + ':' if (UseCapturedNS_ and self.Leg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLeg>%s</%sLeg>%s' % (namespaceprefix_ , self.gds_format_integer(self.Leg, input_name='Leg'), namespaceprefix_ , eol_))
        if self.LegOrder is not None:
            namespaceprefix_ = self.LegOrder_nsprefix_ + ':' if (UseCapturedNS_ and self.LegOrder_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLegOrder>%s</%sLegOrder>%s' % (namespaceprefix_ , self.gds_format_integer(self.LegOrder, input_name='LegOrder'), namespaceprefix_ , eol_))
        if self.TeamMemberName is not None:
            namespaceprefix_ = self.TeamMemberName_nsprefix_ + ':' if (UseCapturedNS_ and self.TeamMemberName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTeamMemberName>%s</%sTeamMemberName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TeamMemberName), input_name='TeamMemberName')), namespaceprefix_ , eol_))
        if self.CourseName is not None:
            namespaceprefix_ = self.CourseName_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseName>%s</%sCourseName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseName), input_name='CourseName')), namespaceprefix_ , eol_))
        if self.CourseFamily is not None:
            namespaceprefix_ = self.CourseFamily_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseFamily_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseFamily>%s</%sCourseFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseFamily), input_name='CourseFamily')), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EntryId':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EntryId = obj_
            obj_.original_tagname_ = 'EntryId'
        elif nodeName_ == 'BibNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BibNumber')
            value_ = self.gds_validate_string(value_, node, 'BibNumber')
            self.BibNumber = value_
            self.BibNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'Leg' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Leg')
            ival_ = self.gds_validate_integer(ival_, node, 'Leg')
            self.Leg = ival_
            self.Leg_nsprefix_ = child_.prefix
        elif nodeName_ == 'LegOrder' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LegOrder')
            ival_ = self.gds_validate_integer(ival_, node, 'LegOrder')
            self.LegOrder = ival_
            self.LegOrder_nsprefix_ = child_.prefix
        elif nodeName_ == 'TeamMemberName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TeamMemberName')
            value_ = self.gds_validate_string(value_, node, 'TeamMemberName')
            self.TeamMemberName = value_
            self.TeamMemberName_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseName')
            value_ = self.gds_validate_string(value_, node, 'CourseName')
            self.CourseName = value_
            self.CourseName_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseFamily')
            value_ = self.gds_validate_string(value_, node, 'CourseFamily')
            self.CourseFamily = value_
            self.CourseFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class TeamMemberCourseAssignment


class Course(GeneratedsSuper):
    """Defines a course, i.e. a number of controls including start and finish.
    The number of competitors that this course has been assigned to."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfCompetitors=None, modifyTime=None, Id=None, Name=None, CourseFamily=None, Length=None, Climb=None, CourseControl=None, MapId=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfCompetitors = _cast(int, numberOfCompetitors)
        self.numberOfCompetitors_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.CourseFamily = CourseFamily
        self.CourseFamily_nsprefix_ = None
        self.Length = Length
        self.Length_nsprefix_ = None
        self.Climb = Climb
        self.Climb_nsprefix_ = None
        if CourseControl is None:
            self.CourseControl = []
        else:
            self.CourseControl = CourseControl
        self.CourseControl_nsprefix_ = None
        self.MapId = MapId
        self.MapId_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Course)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Course.subclass:
            return Course.subclass(*args_, **kwargs_)
        else:
            return Course(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_CourseFamily(self):
        return self.CourseFamily
    def set_CourseFamily(self, CourseFamily):
        self.CourseFamily = CourseFamily
    def get_Length(self):
        return self.Length
    def set_Length(self, Length):
        self.Length = Length
    def get_Climb(self):
        return self.Climb
    def set_Climb(self, Climb):
        self.Climb = Climb
    def get_CourseControl(self):
        return self.CourseControl
    def set_CourseControl(self, CourseControl):
        self.CourseControl = CourseControl
    def add_CourseControl(self, value):
        self.CourseControl.append(value)
    def insert_CourseControl_at(self, index, value):
        self.CourseControl.insert(index, value)
    def replace_CourseControl_at(self, index, value):
        self.CourseControl[index] = value
    def get_MapId(self):
        return self.MapId
    def set_MapId(self, MapId):
        self.MapId = MapId
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_numberOfCompetitors(self):
        return self.numberOfCompetitors
    def set_numberOfCompetitors(self, numberOfCompetitors):
        self.numberOfCompetitors = numberOfCompetitors
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.CourseFamily is not None or
            self.Length is not None or
            self.Climb is not None or
            self.CourseControl or
            self.MapId is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Course', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Course')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Course':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Course')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Course', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Course'):
        if self.numberOfCompetitors is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            outfile.write(' numberOfCompetitors="%s"' % self.gds_format_integer(self.numberOfCompetitors, input_name='numberOfCompetitors'))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Course', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.CourseFamily is not None:
            namespaceprefix_ = self.CourseFamily_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseFamily_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseFamily>%s</%sCourseFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseFamily), input_name='CourseFamily')), namespaceprefix_ , eol_))
        if self.Length is not None:
            namespaceprefix_ = self.Length_nsprefix_ + ':' if (UseCapturedNS_ and self.Length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLength>%s</%sLength>%s' % (namespaceprefix_ , self.gds_format_double(self.Length, input_name='Length'), namespaceprefix_ , eol_))
        if self.Climb is not None:
            namespaceprefix_ = self.Climb_nsprefix_ + ':' if (UseCapturedNS_ and self.Climb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimb>%s</%sClimb>%s' % (namespaceprefix_ , self.gds_format_double(self.Climb, input_name='Climb'), namespaceprefix_ , eol_))
        for CourseControl_ in self.CourseControl:
            namespaceprefix_ = self.CourseControl_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseControl_nsprefix_) else ''
            CourseControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CourseControl', pretty_print=pretty_print)
        if self.MapId is not None:
            namespaceprefix_ = self.MapId_nsprefix_ + ':' if (UseCapturedNS_ and self.MapId_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapId>%s</%sMapId>%s' % (namespaceprefix_ , self.gds_format_integer(self.MapId, input_name='MapId'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfCompetitors', node)
        if value is not None and 'numberOfCompetitors' not in already_processed:
            already_processed.add('numberOfCompetitors')
            self.numberOfCompetitors = self.gds_parse_integer(value, node, 'numberOfCompetitors')
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseFamily')
            value_ = self.gds_validate_string(value_, node, 'CourseFamily')
            self.CourseFamily = value_
            self.CourseFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'Length' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Length')
            fval_ = self.gds_validate_double(fval_, node, 'Length')
            self.Length = fval_
            self.Length_nsprefix_ = child_.prefix
        elif nodeName_ == 'Climb' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Climb')
            fval_ = self.gds_validate_double(fval_, node, 'Climb')
            self.Climb = fval_
            self.Climb_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseControl':
            obj_ = CourseControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CourseControl.append(obj_)
            obj_.original_tagname_ = 'CourseControl'
        elif nodeName_ == 'MapId' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MapId')
            ival_ = self.gds_validate_integer(ival_, node, 'MapId')
            self.MapId = ival_
            self.MapId_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Course


class SimpleCourse(GeneratedsSuper):
    """Defines a course, excluding controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, Name=None, CourseFamily=None, Length=None, Climb=None, NumberOfControls=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.CourseFamily = CourseFamily
        self.CourseFamily_nsprefix_ = None
        self.Length = Length
        self.Length_nsprefix_ = None
        self.Climb = Climb
        self.Climb_nsprefix_ = None
        self.NumberOfControls = NumberOfControls
        self.NumberOfControls_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleCourse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleCourse.subclass:
            return SimpleCourse.subclass(*args_, **kwargs_)
        else:
            return SimpleCourse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_CourseFamily(self):
        return self.CourseFamily
    def set_CourseFamily(self, CourseFamily):
        self.CourseFamily = CourseFamily
    def get_Length(self):
        return self.Length
    def set_Length(self, Length):
        self.Length = Length
    def get_Climb(self):
        return self.Climb
    def set_Climb(self, Climb):
        self.Climb = Climb
    def get_NumberOfControls(self):
        return self.NumberOfControls
    def set_NumberOfControls(self, NumberOfControls):
        self.NumberOfControls = NumberOfControls
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.CourseFamily is not None or
            self.Length is not None or
            self.Climb is not None or
            self.NumberOfControls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='SimpleCourse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleCourse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleCourse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleCourse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleCourse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleCourse'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='SimpleCourse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), namespaceprefix_ , eol_))
        if self.CourseFamily is not None:
            namespaceprefix_ = self.CourseFamily_nsprefix_ + ':' if (UseCapturedNS_ and self.CourseFamily_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCourseFamily>%s</%sCourseFamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CourseFamily), input_name='CourseFamily')), namespaceprefix_ , eol_))
        if self.Length is not None:
            namespaceprefix_ = self.Length_nsprefix_ + ':' if (UseCapturedNS_ and self.Length_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLength>%s</%sLength>%s' % (namespaceprefix_ , self.gds_format_double(self.Length, input_name='Length'), namespaceprefix_ , eol_))
        if self.Climb is not None:
            namespaceprefix_ = self.Climb_nsprefix_ + ':' if (UseCapturedNS_ and self.Climb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClimb>%s</%sClimb>%s' % (namespaceprefix_ , self.gds_format_double(self.Climb, input_name='Climb'), namespaceprefix_ , eol_))
        if self.NumberOfControls is not None:
            namespaceprefix_ = self.NumberOfControls_nsprefix_ + ':' if (UseCapturedNS_ and self.NumberOfControls_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfControls>%s</%sNumberOfControls>%s' % (namespaceprefix_ , self.gds_format_integer(self.NumberOfControls, input_name='NumberOfControls'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'CourseFamily':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CourseFamily')
            value_ = self.gds_validate_string(value_, node, 'CourseFamily')
            self.CourseFamily = value_
            self.CourseFamily_nsprefix_ = child_.prefix
        elif nodeName_ == 'Length' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Length')
            fval_ = self.gds_validate_double(fval_, node, 'Length')
            self.Length = fval_
            self.Length_nsprefix_ = child_.prefix
        elif nodeName_ == 'Climb' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Climb')
            fval_ = self.gds_validate_double(fval_, node, 'Climb')
            self.Climb = fval_
            self.Climb_nsprefix_ = child_.prefix
        elif nodeName_ == 'NumberOfControls' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumberOfControls')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfControls')
            self.NumberOfControls = ival_
            self.NumberOfControls_nsprefix_ = child_.prefix
# end class SimpleCourse


class SimpleRaceCourse(SimpleCourse):
    """Defines a course for a certain race, excluding controls.
    The ordinal number of the race that the information belongs to for a multi-
    race event, starting at 1."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SimpleCourse
    def __init__(self, Id=None, Name=None, CourseFamily=None, Length=None, Climb=None, NumberOfControls=None, raceNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SimpleRaceCourse, self).__init__(Id, Name, CourseFamily, Length, Climb, NumberOfControls,  **kwargs_)
        self.raceNumber = _cast(int, raceNumber)
        self.raceNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleRaceCourse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleRaceCourse.subclass:
            return SimpleRaceCourse.subclass(*args_, **kwargs_)
        else:
            return SimpleRaceCourse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_raceNumber(self):
        return self.raceNumber
    def set_raceNumber(self, raceNumber):
        self.raceNumber = raceNumber
    def hasContent_(self):
        if (
            super(SimpleRaceCourse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SimpleRaceCourse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleRaceCourse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleRaceCourse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleRaceCourse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleRaceCourse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleRaceCourse'):
        super(SimpleRaceCourse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleRaceCourse')
        if self.raceNumber is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            outfile.write(' raceNumber="%s"' % self.gds_format_integer(self.raceNumber, input_name='raceNumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SimpleRaceCourse', fromsubclass_=False, pretty_print=True):
        super(SimpleRaceCourse, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('raceNumber', node)
        if value is not None and 'raceNumber' not in already_processed:
            already_processed.add('raceNumber')
            self.raceNumber = self.gds_parse_integer(value, node, 'raceNumber')
        super(SimpleRaceCourse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SimpleRaceCourse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SimpleRaceCourse


class CourseControl(GeneratedsSuper):
    """A control included in a particular course.
    The type of the control: (ordinary) control, start, finish, crossing point
    or end of marked route. If this attribute is specified, it overrides
    the corresponding Control's type.
    Non-broken sequences of course controls having randomOrder set to true can
    be visited in an arbitrary order.
    Any special instruction applied at the control, see the column G as defined
    in International Specification for Control Descriptions.
    The length of the taped route in meters. Only to be specified if
    specialInstruction is TapedRoute or FunnelTapedRoute and if different
    from the value specified in LegLength element, i.e. when Special
    Instruction 13.1 is used."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, randomOrder=False, specialInstruction='None', tapedRouteLength=None, modifyTime=None, Control=None, MapText=None, MapTextPosition=None, LegLength=None, Score=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.randomOrder = _cast(bool, randomOrder)
        self.randomOrder_nsprefix_ = None
        self.specialInstruction = _cast(None, specialInstruction)
        self.specialInstruction_nsprefix_ = None
        self.tapedRouteLength = _cast(float, tapedRouteLength)
        self.tapedRouteLength_nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        if Control is None:
            self.Control = []
        else:
            self.Control = Control
        self.Control_nsprefix_ = None
        self.MapText = MapText
        self.MapText_nsprefix_ = None
        self.MapTextPosition = MapTextPosition
        self.MapTextPosition_nsprefix_ = None
        self.LegLength = LegLength
        self.LegLength_nsprefix_ = None
        self.Score = Score
        self.Score_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CourseControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CourseControl.subclass:
            return CourseControl.subclass(*args_, **kwargs_)
        else:
            return CourseControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Control(self):
        return self.Control
    def set_Control(self, Control):
        self.Control = Control
    def add_Control(self, value):
        self.Control.append(value)
    def insert_Control_at(self, index, value):
        self.Control.insert(index, value)
    def replace_Control_at(self, index, value):
        self.Control[index] = value
    def get_MapText(self):
        return self.MapText
    def set_MapText(self, MapText):
        self.MapText = MapText
    def get_MapTextPosition(self):
        return self.MapTextPosition
    def set_MapTextPosition(self, MapTextPosition):
        self.MapTextPosition = MapTextPosition
    def get_LegLength(self):
        return self.LegLength
    def set_LegLength(self, LegLength):
        self.LegLength = LegLength
    def get_Score(self):
        return self.Score
    def set_Score(self, Score):
        self.Score = Score
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_randomOrder(self):
        return self.randomOrder
    def set_randomOrder(self, randomOrder):
        self.randomOrder = randomOrder
    def get_specialInstruction(self):
        return self.specialInstruction
    def set_specialInstruction(self, specialInstruction):
        self.specialInstruction = specialInstruction
    def get_tapedRouteLength(self):
        return self.tapedRouteLength
    def set_tapedRouteLength(self, tapedRouteLength):
        self.tapedRouteLength = tapedRouteLength
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def validate_ControlType(self, value):
        # Validate type ControlType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Control', 'Start', 'Finish', 'CrossingPoint', 'EndOfMarkedRoute']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ControlType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_specialInstructionType(self, value):
        # Validate type specialInstructionType, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['None', 'TapedRoute', 'FunnelTapedRoute', 'MandatoryCrossingPoint', 'MandatoryOutOfBoundsAreaPassage']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on specialInstructionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.Control or
            self.MapText is not None or
            self.MapTextPosition is not None or
            self.LegLength is not None or
            self.Score is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CourseControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CourseControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CourseControl':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CourseControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CourseControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CourseControl'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.randomOrder and 'randomOrder' not in already_processed:
            already_processed.add('randomOrder')
            outfile.write(' randomOrder="%s"' % self.gds_format_boolean(self.randomOrder, input_name='randomOrder'))
        if self.specialInstruction != "None" and 'specialInstruction' not in already_processed:
            already_processed.add('specialInstruction')
            outfile.write(' specialInstruction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.specialInstruction), input_name='specialInstruction')), ))
        if self.tapedRouteLength is not None and 'tapedRouteLength' not in already_processed:
            already_processed.add('tapedRouteLength')
            outfile.write(' tapedRouteLength="%s"' % self.gds_format_double(self.tapedRouteLength, input_name='tapedRouteLength'))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='CourseControl', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Control_ in self.Control:
            namespaceprefix_ = self.Control_nsprefix_ + ':' if (UseCapturedNS_ and self.Control_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sControl>%s</%sControl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Control_), input_name='Control')), namespaceprefix_ , eol_))
        if self.MapText is not None:
            namespaceprefix_ = self.MapText_nsprefix_ + ':' if (UseCapturedNS_ and self.MapText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapText>%s</%sMapText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MapText), input_name='MapText')), namespaceprefix_ , eol_))
        if self.MapTextPosition is not None:
            namespaceprefix_ = self.MapTextPosition_nsprefix_ + ':' if (UseCapturedNS_ and self.MapTextPosition_nsprefix_) else ''
            self.MapTextPosition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapTextPosition', pretty_print=pretty_print)
        if self.LegLength is not None:
            namespaceprefix_ = self.LegLength_nsprefix_ + ':' if (UseCapturedNS_ and self.LegLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLegLength>%s</%sLegLength>%s' % (namespaceprefix_ , self.gds_format_double(self.LegLength, input_name='LegLength'), namespaceprefix_ , eol_))
        if self.Score is not None:
            namespaceprefix_ = self.Score_nsprefix_ + ':' if (UseCapturedNS_ and self.Score_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sScore>%s</%sScore>%s' % (namespaceprefix_ , self.gds_format_double(self.Score, input_name='Score'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_ControlType(self.type_)    # validate type ControlType
        value = find_attr_value_('randomOrder', node)
        if value is not None and 'randomOrder' not in already_processed:
            already_processed.add('randomOrder')
            if value in ('true', '1'):
                self.randomOrder = True
            elif value in ('false', '0'):
                self.randomOrder = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('specialInstruction', node)
        if value is not None and 'specialInstruction' not in already_processed:
            already_processed.add('specialInstruction')
            self.specialInstruction = value
            self.validate_specialInstructionType(self.specialInstruction)    # validate type specialInstructionType
        value = find_attr_value_('tapedRouteLength', node)
        if value is not None and 'tapedRouteLength' not in already_processed:
            already_processed.add('tapedRouteLength')
            value = self.gds_parse_double(value, node, 'tapedRouteLength')
            self.tapedRouteLength = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Control':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Control')
            value_ = self.gds_validate_string(value_, node, 'Control')
            self.Control.append(value_)
            self.Control_nsprefix_ = child_.prefix
        elif nodeName_ == 'MapText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MapText')
            value_ = self.gds_validate_string(value_, node, 'MapText')
            self.MapText = value_
            self.MapText_nsprefix_ = child_.prefix
        elif nodeName_ == 'MapTextPosition':
            obj_ = MapPosition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapTextPosition = obj_
            obj_.original_tagname_ = 'MapTextPosition'
        elif nodeName_ == 'LegLength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'LegLength')
            fval_ = self.gds_validate_double(fval_, node, 'LegLength')
            self.LegLength = fval_
            self.LegLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'Score' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Score')
            fval_ = self.gds_validate_double(fval_, node, 'Score')
            self.Score = fval_
            self.Score_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class CourseControl


class Service(GeneratedsSuper):
    """Defines a general purpose service request, e.g. for rental card or
    accomodation.
    Used to mark special services, e.g. rental cards whose fees that are to be
    used in entry scenarios."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, modifyTime=None, Id=None, Name=None, Fee=None, Description=None, MaxNumber=None, RequestedNumber=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Fee is None:
            self.Fee = []
        else:
            self.Fee = Fee
        self.Fee_nsprefix_ = None
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Description_nsprefix_ = None
        self.MaxNumber = MaxNumber
        self.MaxNumber_nsprefix_ = None
        self.RequestedNumber = RequestedNumber
        self.RequestedNumber_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Service)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def add_Name(self, value):
        self.Name.append(value)
    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)
    def replace_Name_at(self, index, value):
        self.Name[index] = value
    def get_Fee(self):
        return self.Fee
    def set_Fee(self, Fee):
        self.Fee = Fee
    def add_Fee(self, value):
        self.Fee.append(value)
    def insert_Fee_at(self, index, value):
        self.Fee.insert(index, value)
    def replace_Fee_at(self, index, value):
        self.Fee[index] = value
    def get_Description(self):
        return self.Description
    def set_Description(self, Description):
        self.Description = Description
    def add_Description(self, value):
        self.Description.append(value)
    def insert_Description_at(self, index, value):
        self.Description.insert(index, value)
    def replace_Description_at(self, index, value):
        self.Description[index] = value
    def get_MaxNumber(self):
        return self.MaxNumber
    def set_MaxNumber(self, MaxNumber):
        self.MaxNumber = MaxNumber
    def get_RequestedNumber(self):
        return self.RequestedNumber
    def set_RequestedNumber(self, RequestedNumber):
        self.RequestedNumber = RequestedNumber
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name or
            self.Fee or
            self.Description or
            self.MaxNumber is not None or
            self.RequestedNumber is not None or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Service', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Service')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Service':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Service', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Service'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Fee_ in self.Fee:
            namespaceprefix_ = self.Fee_nsprefix_ + ':' if (UseCapturedNS_ and self.Fee_nsprefix_) else ''
            Fee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Fee', pretty_print=pretty_print)
        for Description_ in self.Description:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (UseCapturedNS_ and self.Description_nsprefix_) else ''
            Description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description', pretty_print=pretty_print)
        if self.MaxNumber is not None:
            namespaceprefix_ = self.MaxNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.MaxNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxNumber>%s</%sMaxNumber>%s' % (namespaceprefix_ , self.gds_format_double(self.MaxNumber, input_name='MaxNumber'), namespaceprefix_ , eol_))
        if self.RequestedNumber is not None:
            namespaceprefix_ = self.RequestedNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.RequestedNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRequestedNumber>%s</%sRequestedNumber>%s' % (namespaceprefix_ , self.gds_format_double(self.RequestedNumber, input_name='RequestedNumber'), namespaceprefix_ , eol_))
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Name':
            obj_ = LanguageString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Fee':
            obj_ = Fee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Fee.append(obj_)
            obj_.original_tagname_ = 'Fee'
        elif nodeName_ == 'Description':
            obj_ = LanguageString.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'MaxNumber' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'MaxNumber')
            fval_ = self.gds_validate_double(fval_, node, 'MaxNumber')
            self.MaxNumber = fval_
            self.MaxNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'RequestedNumber' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'RequestedNumber')
            fval_ = self.gds_validate_double(fval_, node, 'RequestedNumber')
            self.RequestedNumber = fval_
            self.RequestedNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class Service


class OrganisationServiceRequest(GeneratedsSuper):
    """Service requests made by an organisation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Organisation=None, ServiceRequest=None, PersonServiceRequest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Organisation = Organisation
        self.Organisation_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
        if PersonServiceRequest is None:
            self.PersonServiceRequest = []
        else:
            self.PersonServiceRequest = PersonServiceRequest
        self.PersonServiceRequest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationServiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationServiceRequest.subclass:
            return OrganisationServiceRequest.subclass(*args_, **kwargs_)
        else:
            return OrganisationServiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Organisation(self):
        return self.Organisation
    def set_Organisation(self, Organisation):
        self.Organisation = Organisation
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def get_PersonServiceRequest(self):
        return self.PersonServiceRequest
    def set_PersonServiceRequest(self, PersonServiceRequest):
        self.PersonServiceRequest = PersonServiceRequest
    def add_PersonServiceRequest(self, value):
        self.PersonServiceRequest.append(value)
    def insert_PersonServiceRequest_at(self, index, value):
        self.PersonServiceRequest.insert(index, value)
    def replace_PersonServiceRequest_at(self, index, value):
        self.PersonServiceRequest[index] = value
    def hasContent_(self):
        if (
            self.Organisation is not None or
            self.ServiceRequest or
            self.PersonServiceRequest
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OrganisationServiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationServiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganisationServiceRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganisationServiceRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganisationServiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganisationServiceRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='OrganisationServiceRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Organisation is not None:
            namespaceprefix_ = self.Organisation_nsprefix_ + ':' if (UseCapturedNS_ and self.Organisation_nsprefix_) else ''
            self.Organisation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organisation', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
        for PersonServiceRequest_ in self.PersonServiceRequest:
            namespaceprefix_ = self.PersonServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonServiceRequest_nsprefix_) else ''
            PersonServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonServiceRequest', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Organisation':
            obj_ = Organisation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organisation = obj_
            obj_.original_tagname_ = 'Organisation'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
        elif nodeName_ == 'PersonServiceRequest':
            obj_ = PersonServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonServiceRequest.append(obj_)
            obj_.original_tagname_ = 'PersonServiceRequest'
# end class OrganisationServiceRequest


class PersonServiceRequest(GeneratedsSuper):
    """Service requests made by a person."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Person=None, ServiceRequest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        if ServiceRequest is None:
            self.ServiceRequest = []
        else:
            self.ServiceRequest = ServiceRequest
        self.ServiceRequest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonServiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonServiceRequest.subclass:
            return PersonServiceRequest.subclass(*args_, **kwargs_)
        else:
            return PersonServiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_ServiceRequest(self):
        return self.ServiceRequest
    def set_ServiceRequest(self, ServiceRequest):
        self.ServiceRequest = ServiceRequest
    def add_ServiceRequest(self, value):
        self.ServiceRequest.append(value)
    def insert_ServiceRequest_at(self, index, value):
        self.ServiceRequest.insert(index, value)
    def replace_ServiceRequest_at(self, index, value):
        self.ServiceRequest[index] = value
    def hasContent_(self):
        if (
            self.Person is not None or
            self.ServiceRequest
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonServiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonServiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PersonServiceRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonServiceRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonServiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonServiceRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='PersonServiceRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        for ServiceRequest_ in self.ServiceRequest:
            namespaceprefix_ = self.ServiceRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceRequest_nsprefix_) else ''
            ServiceRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceRequest', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = Person.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'ServiceRequest':
            obj_ = ServiceRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceRequest.append(obj_)
            obj_.original_tagname_ = 'ServiceRequest'
# end class PersonServiceRequest


class ServiceRequest(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modifyTime=None, Id=None, Service=None, RequestedQuantity=None, DeliveredQuantity=None, Comment=None, AssignedFee=None, Extensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.Id = Id
        self.Id_nsprefix_ = None
        self.Service = Service
        self.Service_nsprefix_ = None
        self.RequestedQuantity = RequestedQuantity
        self.RequestedQuantity_nsprefix_ = None
        self.DeliveredQuantity = DeliveredQuantity
        self.DeliveredQuantity_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None
        if AssignedFee is None:
            self.AssignedFee = []
        else:
            self.AssignedFee = AssignedFee
        self.AssignedFee_nsprefix_ = None
        self.Extensions = Extensions
        self.Extensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequest.subclass:
            return ServiceRequest.subclass(*args_, **kwargs_)
        else:
            return ServiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_Service(self):
        return self.Service
    def set_Service(self, Service):
        self.Service = Service
    def get_RequestedQuantity(self):
        return self.RequestedQuantity
    def set_RequestedQuantity(self, RequestedQuantity):
        self.RequestedQuantity = RequestedQuantity
    def get_DeliveredQuantity(self):
        return self.DeliveredQuantity
    def set_DeliveredQuantity(self, DeliveredQuantity):
        self.DeliveredQuantity = DeliveredQuantity
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def get_AssignedFee(self):
        return self.AssignedFee
    def set_AssignedFee(self, AssignedFee):
        self.AssignedFee = AssignedFee
    def add_AssignedFee(self, value):
        self.AssignedFee.append(value)
    def insert_AssignedFee_at(self, index, value):
        self.AssignedFee.insert(index, value)
    def replace_AssignedFee_at(self, index, value):
        self.AssignedFee[index] = value
    def get_Extensions(self):
        return self.Extensions
    def set_Extensions(self, Extensions):
        self.Extensions = Extensions
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Service is not None or
            self.RequestedQuantity is not None or
            self.DeliveredQuantity is not None or
            self.Comment is not None or
            self.AssignedFee or
            self.Extensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ServiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequest'):
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='ServiceRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            namespaceprefix_ = self.Id_nsprefix_ + ':' if (UseCapturedNS_ and self.Id_nsprefix_) else ''
            self.Id.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Id', pretty_print=pretty_print)
        if self.Service is not None:
            namespaceprefix_ = self.Service_nsprefix_ + ':' if (UseCapturedNS_ and self.Service_nsprefix_) else ''
            self.Service.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Service', pretty_print=pretty_print)
        if self.RequestedQuantity is not None:
            namespaceprefix_ = self.RequestedQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.RequestedQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRequestedQuantity>%s</%sRequestedQuantity>%s' % (namespaceprefix_ , self.gds_format_double(self.RequestedQuantity, input_name='RequestedQuantity'), namespaceprefix_ , eol_))
        if self.DeliveredQuantity is not None:
            namespaceprefix_ = self.DeliveredQuantity_nsprefix_ + ':' if (UseCapturedNS_ and self.DeliveredQuantity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeliveredQuantity>%s</%sDeliveredQuantity>%s' % (namespaceprefix_ , self.gds_format_double(self.DeliveredQuantity, input_name='DeliveredQuantity'), namespaceprefix_ , eol_))
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespaceprefix_ , eol_))
        for AssignedFee_ in self.AssignedFee:
            namespaceprefix_ = self.AssignedFee_nsprefix_ + ':' if (UseCapturedNS_ and self.AssignedFee_nsprefix_) else ''
            AssignedFee_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssignedFee', pretty_print=pretty_print)
        if self.Extensions is not None:
            namespaceprefix_ = self.Extensions_nsprefix_ + ':' if (UseCapturedNS_ and self.Extensions_nsprefix_) else ''
            self.Extensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Id':
            obj_ = Id.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Id = obj_
            obj_.original_tagname_ = 'Id'
        elif nodeName_ == 'Service':
            obj_ = Service.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Service = obj_
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'RequestedQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'RequestedQuantity')
            fval_ = self.gds_validate_double(fval_, node, 'RequestedQuantity')
            self.RequestedQuantity = fval_
            self.RequestedQuantity_nsprefix_ = child_.prefix
        elif nodeName_ == 'DeliveredQuantity' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'DeliveredQuantity')
            fval_ = self.gds_validate_double(fval_, node, 'DeliveredQuantity')
            self.DeliveredQuantity = fval_
            self.DeliveredQuantity_nsprefix_ = child_.prefix
        elif nodeName_ == 'Comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Comment')
            value_ = self.gds_validate_string(value_, node, 'Comment')
            self.Comment = value_
            self.Comment_nsprefix_ = child_.prefix
        elif nodeName_ == 'AssignedFee':
            obj_ = AssignedFee.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssignedFee.append(obj_)
            obj_.original_tagname_ = 'AssignedFee'
        elif nodeName_ == 'Extensions':
            obj_ = Extensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extensions = obj_
            obj_.original_tagname_ = 'Extensions'
# end class ServiceRequest


class Account(GeneratedsSuper):
    """The bank account of an organisation or an event.
    The account type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Account)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Account', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Account')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Account':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Account')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Account', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Account'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Account', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Account


class Address(GeneratedsSuper):
    """The postal address of a person or organisation.
    The address type, e.g. visitor address or invoice address."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, modifyTime=None, CareOf=None, Street=None, ZipCode=None, City=None, State=None, Country=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.CareOf = CareOf
        self.CareOf_nsprefix_ = None
        self.Street = Street
        self.Street_nsprefix_ = None
        self.ZipCode = ZipCode
        self.ZipCode_nsprefix_ = None
        self.City = City
        self.City_nsprefix_ = None
        self.State = State
        self.State_nsprefix_ = None
        self.Country = Country
        self.Country_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CareOf(self):
        return self.CareOf
    def set_CareOf(self, CareOf):
        self.CareOf = CareOf
    def get_Street(self):
        return self.Street
    def set_Street(self, Street):
        self.Street = Street
    def get_ZipCode(self):
        return self.ZipCode
    def set_ZipCode(self, ZipCode):
        self.ZipCode = ZipCode
    def get_City(self):
        return self.City
    def set_City(self, City):
        self.City = City
    def get_State(self):
        return self.State
    def set_State(self, State):
        self.State = State
    def get_Country(self):
        return self.Country
    def set_Country(self, Country):
        self.Country = Country
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def hasContent_(self):
        if (
            self.CareOf is not None or
            self.Street is not None or
            self.ZipCode is not None or
            self.City is not None or
            self.State is not None or
            self.Country is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Address', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Address')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Address':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Address'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CareOf is not None:
            namespaceprefix_ = self.CareOf_nsprefix_ + ':' if (UseCapturedNS_ and self.CareOf_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCareOf>%s</%sCareOf>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CareOf), input_name='CareOf')), namespaceprefix_ , eol_))
        if self.Street is not None:
            namespaceprefix_ = self.Street_nsprefix_ + ':' if (UseCapturedNS_ and self.Street_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStreet>%s</%sStreet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Street), input_name='Street')), namespaceprefix_ , eol_))
        if self.ZipCode is not None:
            namespaceprefix_ = self.ZipCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ZipCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZipCode>%s</%sZipCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), namespaceprefix_ , eol_))
        if self.City is not None:
            namespaceprefix_ = self.City_nsprefix_ + ':' if (UseCapturedNS_ and self.City_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), namespaceprefix_ , eol_))
        if self.State is not None:
            namespaceprefix_ = self.State_nsprefix_ + ':' if (UseCapturedNS_ and self.State_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sState>%s</%sState>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.State), input_name='State')), namespaceprefix_ , eol_))
        if self.Country is not None:
            namespaceprefix_ = self.Country_nsprefix_ + ':' if (UseCapturedNS_ and self.Country_nsprefix_) else ''
            self.Country.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Country', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CareOf':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CareOf')
            value_ = self.gds_validate_string(value_, node, 'CareOf')
            self.CareOf = value_
            self.CareOf_nsprefix_ = child_.prefix
        elif nodeName_ == 'Street':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Street')
            value_ = self.gds_validate_string(value_, node, 'Street')
            self.Street = value_
            self.Street_nsprefix_ = child_.prefix
        elif nodeName_ == 'ZipCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ZipCode')
            value_ = self.gds_validate_string(value_, node, 'ZipCode')
            self.ZipCode = value_
            self.ZipCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'City':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'City')
            value_ = self.gds_validate_string(value_, node, 'City')
            self.City = value_
            self.City_nsprefix_ = child_.prefix
        elif nodeName_ == 'State':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'State')
            value_ = self.gds_validate_string(value_, node, 'State')
            self.State = value_
            self.State_nsprefix_ = child_.prefix
        elif nodeName_ == 'Country':
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Country = obj_
            obj_.original_tagname_ = 'Country'
# end class Address


class Country(GeneratedsSuper):
    """Defines the name of the country.
    The International Olympic Committee's 3-letter code of the country as
    stated in https://en.wikipedia.org/wiki/List_of_IOC_country_codes. Note
    that several of the IOC codes are different from the standard ISO
    3166-1 alpha-3 codes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, code=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Country.subclass:
            return Country.subclass(*args_, **kwargs_)
        else:
            return Country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Country':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Country')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Country', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Country'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Country', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Country


class Contact(GeneratedsSuper):
    """Contact information for a person, organisation or other entity."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, modifyTime=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if isinstance(modifyTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(modifyTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = modifyTime
        self.modifyTime = initvalue_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_modifyTime(self):
        return self.modifyTime
    def set_modifyTime(self, modifyTime):
        self.modifyTime = modifyTime
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType8(self, value):
        # Validate type typeType8, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhoneNumber', 'MobilePhoneNumber', 'FaxNumber', 'EmailAddress', 'WebAddress', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Contact', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Contact':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Contact')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Contact', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Contact'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.modifyTime is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            outfile.write(' modifyTime="%s"' % self.gds_format_datetime(self.modifyTime, input_name='modifyTime'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Contact', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType8(self.type_)    # validate type typeType8
        value = find_attr_value_('modifyTime', node)
        if value is not None and 'modifyTime' not in already_processed:
            already_processed.add('modifyTime')
            try:
                self.modifyTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (modifyTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Contact


class DateAndOptionalTime(GeneratedsSuper):
    """Defines a point in time which either is known by date and time, or just
    by date. May be used for event dates, when the event date is decided
    before the time of the first start."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Date=None, Time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Date_nsprefix_ = None
        if isinstance(Time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Time, '%H:%M:%S').time()
        else:
            initvalue_ = Time
        self.Time = initvalue_
        self.Time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateAndOptionalTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateAndOptionalTime.subclass:
            return DateAndOptionalTime.subclass(*args_, **kwargs_)
        else:
            return DateAndOptionalTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='DateAndOptionalTime', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateAndOptionalTime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateAndOptionalTime':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateAndOptionalTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateAndOptionalTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateAndOptionalTime'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='DateAndOptionalTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespaceprefix_ , self.gds_format_date(self.Date, input_name='Date'), namespaceprefix_ , eol_))
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespaceprefix_ , self.gds_format_time(self.Time, input_name='Time'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
            self.Date_nsprefix_ = child_.prefix
        elif nodeName_ == 'Time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.Time = dval_
            self.Time_nsprefix_ = child_.prefix
# end class DateAndOptionalTime


class LanguageString(GeneratedsSuper):
    """Defines a text that is given in a particular language.
    The ISO 639-1 two-letter code of the language as stated in
    https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LanguageString)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LanguageString.subclass:
            return LanguageString.subclass(*args_, **kwargs_)
        else:
            return LanguageString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LanguageString', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LanguageString')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LanguageString':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LanguageString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LanguageString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LanguageString'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LanguageString', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LanguageString


class Extensions(GeneratedsSuper):
    """Container element that is used to add custom elements from other
    schemas."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Extensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Extensions.subclass:
            return Extensions.subclass(*args_, **kwargs_)
        else:
            return Extensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Extensions', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Extensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Extensions':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Extensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Extensions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Extensions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.orienteering.org/datastandard/3.0" ', name_='Extensions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'Extensions')
        self.add_anytypeobjs_(content_)
# end class Extensions


class TimeBehindType(GeneratedsSuper):
    """The time, in seconds, that the the team member is behind the winner.
    Fractions of seconds (e.g. 258.7) may be used if the time resolution is
    higher than one second."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeBehindType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeBehindType.subclass:
            return TimeBehindType.subclass(*args_, **kwargs_)
        else:
            return TimeBehindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType5(self, value):
        # Validate type typeType5, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Leg', 'Course']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeBehindType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeBehindType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeBehindType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeBehindType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeBehindType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeBehindType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeBehindType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType5(self.type_)    # validate type typeType5
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TimeBehindType


class PositionType(GeneratedsSuper):
    """The position in the result list for the person that the result belongs
    to. This element should only be present when the Status element is set
    to OK."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PositionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PositionType.subclass:
            return PositionType.subclass(*args_, **kwargs_)
        else:
            return PositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_typeType6(self, value):
        # Validate type typeType6, a restriction on xsd:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Leg', 'Course']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PositionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PositionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PositionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PositionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PositionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PositionType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PositionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType6(self.type_)    # validate type typeType6
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PositionType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BaseMessageElement'
        rootClass = BaseMessageElement
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BaseMessageElement'
        rootClass = BaseMessageElement
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BaseMessageElement'
        rootClass = BaseMessageElement
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'BaseMessageElement'
        rootClass = BaseMessageElement
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from xml_classes2 import *\n\n')
        sys.stdout.write('import xml_classes2 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "Account",
    "Address",
    "Amount",
    "AssignedFee",
    "BaseMessageElement",
    "Class",
    "ClassCourseAssignment",
    "ClassList",
    "ClassResult",
    "ClassStart",
    "ClassType",
    "Competitor",
    "CompetitorList",
    "Contact",
    "Control",
    "ControlAnswer",
    "ControlCard",
    "ControlCardList",
    "Country",
    "Course",
    "CourseControl",
    "CourseData",
    "DateAndOptionalTime",
    "EntryList",
    "EntryReceiver",
    "Event",
    "EventList",
    "EventURL",
    "Extensions",
    "Fee",
    "GeoPosition",
    "Id",
    "Image",
    "InformationItem",
    "LanguageString",
    "Leg",
    "Map",
    "MapPosition",
    "Organisation",
    "OrganisationList",
    "OrganisationServiceRequest",
    "OverallResult",
    "Person",
    "PersonCourseAssignment",
    "PersonEntry",
    "PersonName",
    "PersonRaceResult",
    "PersonRaceStart",
    "PersonResult",
    "PersonServiceRequest",
    "PersonStart",
    "PositionType",
    "Race",
    "RaceClass",
    "RaceCourseData",
    "ResultList",
    "Role",
    "Route",
    "Schedule",
    "Score",
    "Service",
    "ServiceRequest",
    "ServiceRequestList",
    "SimpleCourse",
    "SimpleRaceCourse",
    "SplitTime",
    "StartList",
    "StartName",
    "StartTimeAllocationRequest",
    "TeamCourseAssignment",
    "TeamEntry",
    "TeamEntryPerson",
    "TeamMemberCourseAssignment",
    "TeamMemberRaceResult",
    "TeamMemberRaceStart",
    "TeamMemberResult",
    "TeamMemberStart",
    "TeamResult",
    "TeamStart",
    "TimeBehindType"
]
